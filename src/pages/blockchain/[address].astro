---
import BaseHead from '../../components/BaseHead.astro';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../../consts';
import { BLOCKCHAIN_CONFIG } from '../../config/blockchain.config';
import { getAddressFromAlias, getAliasFromAddress, STORE_ALIASES } from '../../config/aliases.config';
import { CatLabSensorStoreABI, CatLabFactoryABI } from '../../abis';
import { DEPLOYER_ABI } from '../../utils/blockchain-constants';

// Enable server-side rendering for dynamic routes
export const prerender = false;

// Get the address parameter from the URL
const { address: addressOrAlias } = Astro.params;

// Validate Ethereum address format
const isEthereumAddress = /^0x[a-fA-F0-9]{40}$/i.test(addressOrAlias);

let resolvedAddress = addressOrAlias;
let aliasInfo = null;
let error = null;

if (!isEthereumAddress) {
  // Try to resolve as alias
  const addressFromAlias = getAddressFromAlias(addressOrAlias);
  if (addressFromAlias) {
    resolvedAddress = addressFromAlias;
    // Find the full alias info
    const storeAlias = STORE_ALIASES.find(a => a.alias.toLowerCase() === addressOrAlias.toLowerCase());
    if (storeAlias) {
      aliasInfo = {
        alias: storeAlias.alias,
        displayName: storeAlias.displayName
      };
    }
  } else {
    error = `Invalid alias: ${addressOrAlias}`;
    resolvedAddress = null;
  }
} else {
  // Check if this address has an alias
  const alias = getAliasFromAddress(addressOrAlias);
  if (alias) {
    const storeAlias = STORE_ALIASES.find(a => a.address.toLowerCase() === addressOrAlias.toLowerCase());
    if (storeAlias) {
      aliasInfo = {
        alias: storeAlias.alias,
        displayName: storeAlias.displayName
      };
    }
  }
}

// Prepare data for client-side
const pageData = {
  originalParam: addressOrAlias,
  address: resolvedAddress,
  aliasInfo: aliasInfo,
  error: error,
  storeABI: CatLabSensorStoreABI,
  factoryABI: CatLabFactoryABI,
  deployerABI: DEPLOYER_ABI
};

// Prepare configuration for injection
const configJson = JSON.stringify(BLOCKCHAIN_CONFIG);
const pageDataJson = JSON.stringify(pageData);

// Update page title based on alias or address
const pageTitle = aliasInfo 
  ? `${aliasInfo.displayName} | ${SITE_TITLE}`
  : `Blockchain Store ${addressOrAlias} | ${SITE_TITLE}`;
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={pageTitle} description={SITE_DESCRIPTION} />
		
		<!-- React and Babel for JSX -->
		<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
		<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
		<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
		
		<!-- p5.js for visualization -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
		
		<!-- Chart.js with proper module loading -->
		<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
		<script>
			// Wait for Chart.js to load before loading the adapter
			if (typeof Chart !== 'undefined') {
				var script = document.createElement('script');
				script.src = 'https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
				document.head.appendChild(script);
			}
		</script>
		
		<!-- Tailwind CSS -->
		
		<style>
			body {
				margin: 0;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
				background-color: #f9fafb;
				color: #111827;
			}
			
			@keyframes fadeIn {
				from {
					opacity: 0;
					transform: scale(0.95);
				}
				to {
					opacity: 1;
					transform: scale(1);
				}
			}
			
			/* P5 Container Styling for light theme */
			#p5-container {
				border-radius: 12px;
				overflow: hidden;
				transition: all 0.3s ease;
				border: 2px solid #d1d5db;
				background: rgba(255, 255, 255, 0.95);
				box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
			}
			
			/* Card Styling for light theme */
			.card {
				background-color: #ffffff;
				border: 1px solid #e5e7eb;
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
				transition: all 0.2s ease;
			}
			.card:hover {
				box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
			}
			
			/* Button Styling */
			.btn {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				padding: 0.5rem 1rem;
				font-size: 0.875rem;
				font-weight: 500;
				border-radius: 0.375rem;
				transition: all 0.2s ease;
				border: 1px solid transparent;
				cursor: pointer;
			}
			.btn-primary {
				background-color: #3b82f6;
				color: white;
			}
			.btn-primary:hover {
				background-color: #2563eb;
				transform: translateY(-1px);
				box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
			}
			.btn-secondary {
				background-color: #ffffff;
				color: #374151;
				border-color: #d1d5db;
			}
			.btn-secondary:hover {
				background-color: #f9fafb;
				border-color: #9ca3af;
			}
			.btn-success {
				background-color: #10b981;
				color: white;
			}
			.btn-success:hover {
				background-color: #059669;
			}
			
			/* Input Styling for light theme */
			.input {
				background-color: #f9fafb;
				border-color: #d1d5db;
				color: #111827;
			}
			.input::placeholder {
				color: #6b7280;
			}
			
			.loading-skeleton {
				animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
				background-color: #e5e7eb;
			}
			@keyframes pulse {
				0%, 100% { opacity: 1; }
				50% { opacity: .5; }
			}
			
			/* Modern Table Styling */
			.modern-table {
				width: 100%;
				border-collapse: separate;
				border-spacing: 0;
				table-layout: auto;
			}
			.modern-table thead tr {
				background-color: #f9fafb;
			}
			.modern-table th {
				padding: 0.75rem 1rem;
				text-align: left;
				font-size: 0.875rem;
				font-weight: 600;
				color: #374151;
				border-bottom: 2px solid #e5e7eb;
				white-space: nowrap;
			}
			.modern-table th:first-child {
				padding-left: 1.5rem;
			}
			.modern-table th:last-child {
				padding-right: 1.5rem;
			}
			.modern-table td {
				padding: 0.75rem 1rem;
				border-bottom: 1px solid #f3f4f6;
				font-size: 0.875rem;
				white-space: nowrap;
			}
			.modern-table td:first-child {
				padding-left: 1.5rem;
			}
			.modern-table td:last-child {
				padding-right: 1.5rem;
			}
			.modern-table tbody tr:hover {
				background-color: #f9fafb;
			}
			.modern-table tbody tr:last-child td {
				border-bottom: none;
			}
			
			/* Fluid column widths */
			.modern-table th:nth-child(1),
			.modern-table td:nth-child(1) {
				/* Timestamp - no fixed width, natural sizing */
				white-space: nowrap;
			}
			.modern-table th:last-child,
			.modern-table td:last-child {
				/* Block (with tx link) - last column */
				text-align: right;
			}
			/* Data columns - between timestamp and block */
			.modern-table th:not(:nth-child(1)):not(:last-child),
			.modern-table td:not(:nth-child(1)):not(:last-child) {
				text-align: right;
			}
			
			/* Fix header alignment */
			.modern-table th {
				vertical-align: middle;
			}
			
			/* Additional spacing for better readability */
			.modern-table th:not(:last-child),
			.modern-table td:not(:last-child) {
				padding-right: 2rem;
			}
			
			/* Responsive adjustments */
			@media (max-width: 1024px) {
				.modern-table th,
				.modern-table td {
					padding: 0.75rem 1rem;
					font-size: 0.75rem;
				}
				.modern-table th:not(:last-child),
				.modern-table td:not(:last-child) {
					padding-right: 1.5rem;
				}
			}
			
			/* Stat Card Styling */
			.stat-card {
				background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
				border: 1px solid #e5e7eb;
				border-radius: 0.75rem;
				padding: 1.5rem;
				transition: all 0.2s ease;
			}
			.stat-card:hover {
				transform: translateY(-2px);
				box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
			}
		</style>
	</head>
	<body class="light">
		<Header />
		<main>
			<div id="blockchain-app"></div>
		</main>
		<Footer />

		<script type="module" define:vars={{ BLOCKCHAIN_CONFIG: configJson, PAGE_DATA: pageDataJson }}>
			// Import viem modules
			import { createPublicClient, http, parseAbi, formatEther, decodeEventLog, encodeFunctionData, decodeFunctionResult } from 'https://esm.sh/viem@2.21.19';
			import { mainnet, sepolia, anvil } from 'https://esm.sh/viem@2.21.19/chains';
			
			// Custom chain configurations
                        const prioritizedJibchainRpcUrls = [
                                'https://rpc-l1.jibchain.net',
                                'https://rpc2-l1.jbc.xpool.pw',
                                'https://rpc-l1.jbc.xpool.pw',
                                'https://rpc-l1.inan.in.th'
                        ];

                        const jibchainL1 = {
                                id: 8899,
                                name: 'JIBCHAIN L1',
                                network: 'jibchain',
                                nativeCurrency: { name: 'JBC', symbol: 'JBC', decimals: 18 },
                                rpcUrls: {
                                        default: { http: prioritizedJibchainRpcUrls },
                                        public: { http: prioritizedJibchainRpcUrls }
                                },
                                blockExplorers: {
                                        default: { name: 'JBC Explorer', url: 'https://exp.jibchain.net' }
                                }
                        };
			
			const sichang = {
				id: 700011,
				name: 'SiChang',
				network: 'sichang',
				nativeCurrency: { name: 'TCH', symbol: 'TCH', decimals: 18 },
				rpcUrls: {
					default: { http: ['https://sichang-rpc.thaichain.org'] },
					public: { http: ['https://sichang-rpc.thaichain.org'] }
				},
				blockExplorers: {
					default: { name: 'SiChang Explorer', url: 'https://sichang.thaichain.org' }
				}
			};
			
			// Make viem and chains available globally
			window.viem = { createPublicClient, http, parseAbi, formatEther, decodeEventLog, encodeFunctionData, decodeFunctionResult };
			window.chains = { mainnet, sepolia, anvil, jibchainL1, sichang };

			// Parse page data from server
			const pageData = JSON.parse(PAGE_DATA);
			
			// Use resolved address from server or fall back to URL parsing
			const storeAddress = pageData.address || (() => {
				const urlParts = window.location.pathname.split('/');
				return urlParts[urlParts.length - 1];
			})();

			// Contract ABIs and configurations
			// Configuration injected at build time
			const CONTRACTS = JSON.parse(BLOCKCHAIN_CONFIG);
			
			// Use the ABI loaded from abis.js
			const STORE_ABI = pageData.storeABI;

			// Event definitions for reading blockchain events
			const RECORD_STORED_EVENT = {
				type: 'event',
				name: 'RecordStored',
				inputs: [
					{ name: 'sensor', type: 'address', indexed: true },
					{ name: 'timestamp', type: 'uint256', indexed: false },
					{ name: 'values', type: 'int256[]', indexed: false }
				]
			};

			// Utility functions adapted from web3-iot-factory
			function parseScalingFactor(unit) {
				const match = unit.match(/x\s*(\d+)/i);
				return match ? parseInt(match[1]) : 100; // Default to 100 if no scaling found
			}

			function formatScaledValue(value, unit) {
				// If unit contains "count", return the raw integer value as it's a counter
				if (unit.toLowerCase().includes('count')) {
					return Math.round(Number(value)).toString();
				}
				
				const scaleFactor = parseScalingFactor(unit);
				const numValue = Number(value);
				const decimalValue = numValue / scaleFactor;
				const decimalPlaces = Math.log10(scaleFactor);
				return decimalValue.toFixed(Math.max(0, decimalPlaces));
			}

			// Process event logs
			function processRecordLogs(logs) {
				return logs
					.filter(log => log.args && log.args.sensor && log.args.timestamp && log.args.values)
					.map(log => ({
						sensor: log.args.sensor,
						timestamp: Number(log.args.timestamp),
						values: log.args.values.map(v => Number(v)),
						blockNumber: log.blockNumber,
						transactionHash: log.transactionHash
					}))
					.sort((a, b) => b.timestamp - a.timestamp); // Sort by timestamp descending
			}

			// Smart water level filtering with time-gap awareness (FloodBoy020 only)
			function filterWaterLevelData(records, fields, storeAddress) {
				// Only apply filtering to FloodBoy020
				const shouldFilter = true || storeAddress && (
					storeAddress.toLowerCase() === '0x1701a62b62813160de104461573a9e6069405655' // FloodBoy020 address
				);
				
				if (!shouldFilter) {
					return records; // Return unfiltered for other sensors
				}
				
				const waterDepthIdx = fields.findIndex(f => f.name === 'water_depth');
				if (waterDepthIdx < 0) return records; // No water_depth field, return all
				
				console.log('Applying water level filtering for FloodBoy020');
				
				return records.filter((record, index, arr) => {
					const waterDepth = record.values[waterDepthIdx];
					
					// 1. Always filter zero values (sensor failures)
					if (waterDepth === 0) {
						console.log('Filtered zero reading at', new Date(record.timestamp * 1000));
						return false;
					}
					
					// 2. Filter impossible values (negative or > 20m)
					// Water depth is in m x10000 units, so 20m = 200000 units
					if (waterDepth < 0 || waterDepth > 200000) { // 200000 = 20m × 10000
						console.log('Filtered impossible value:', waterDepth / 10000, 'm');
						return false;
					}
					
					// 3. Detect isolated spikes (both small and large)
					if (index > 0 && index < arr.length - 1) {
						const prev = arr[index - 1];
						const next = arr[index + 1];
						const prevDepth = prev.values[waterDepthIdx];
						const nextDepth = next.values[waterDepthIdx];
						
						// Check if previous and next readings are similar (returns to baseline)
						const returnToBaseline = Math.abs(prevDepth - nextDepth);
						const avgSurrounding = (prevDepth + nextDepth) / 2;
						const currentDeviation = Math.abs(waterDepth - avgSurrounding);
						
						// Two-tier detection:
						// 1. Fine-grain: If prev/next very similar (<0.05m), filter small spikes (>0.1m)
						// 2. Coarse: If prev/next somewhat similar (<0.1m), filter larger spikes (>0.25m)
						
						if (returnToBaseline < 500 && currentDeviation > 1000) {
							// Very similar baseline, filter small spikes (0.1m+)
							console.log('Filtered fine spike:', waterDepth / 10000, 'm (deviation:', 
								currentDeviation / 10000, 'm) from baseline', avgSurrounding / 10000, 'm');
							return false;
						} else if (returnToBaseline < 1000 && currentDeviation > 2500) {
							// Similar baseline, filter medium spikes (0.25m+)
							console.log('Filtered medium spike:', waterDepth / 10000, 'm (deviation:', 
								currentDeviation / 10000, 'm) from baseline', avgSurrounding / 10000, 'm');
							return false;
						}
					}
					
					// 4. Smart rate-of-change detection with time gap awareness
					if (index > 0) {
						const prev = arr[index - 1];
						const timeDiff = Math.abs(record.timestamp - prev.timestamp) / 60; // minutes
						const waterChange = Math.abs(waterDepth - prev.values[waterDepthIdx]);
						
						// Expected transmission interval (5-10 minutes normal operation)
						const NORMAL_INTERVAL = 15; // minutes
						// MAX_CHANGE_PER_INTERVAL in m x10000 units (0.5m = 5000 units)
						const MAX_CHANGE_PER_INTERVAL = 5000; // 5000 = 0.5m × 10000
						
						// If transmission is regular (no gap), apply strict filtering
						if (timeDiff <= NORMAL_INTERVAL) {
							if (waterChange > MAX_CHANGE_PER_INTERVAL) {
								console.log('Filtered outlier:', waterChange / 10000, 'm change in', timeDiff, 'min at', 
									new Date(record.timestamp * 1000));
								return false;
							}
						} else {
							// There was a gap in transmission - sensor was offline
							// Calculate acceptable change based on time gap
							const maxAcceptableChange = (timeDiff / NORMAL_INTERVAL) * MAX_CHANGE_PER_INTERVAL;
							
							if (waterChange > maxAcceptableChange) {
								// Even accounting for the gap, this change is too large
								console.log('Filtered extreme outlier:', waterChange / 10000, 'm change in', 
									timeDiff, 'min gap at', new Date(record.timestamp * 1000));
								return false;
							}
						}
					}
					
					return true;
				});
			}

			// FloodboyVisualization React Component (inline)
			function FloodboyVisualization({ waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead }) {
				const sketchRef = React.useRef(null);
				const p5InstanceRef = React.useRef(null);
				const propsRef = React.useRef({ waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead });

				// Update props ref
				React.useEffect(() => {
					propsRef.current = { waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead };
				}, [waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead]);

				React.useEffect(() => {
					const sketch = (p) => {
						p.setup = () => {
							const canvas = p.createCanvas(350, 420);
							canvas.parent(sketchRef.current);
							p.frameRate(30);
						};

						p.draw = () => {
							p.clear();
							p.background(255, 255, 255, 0);
							
							const { 
								waterLevel: currentWaterLevel, 
								airLevel: currentAirLevel, 
								sensorMode: currentSensorMode, 
								installationHeight: currentInstallationHeight, 
								showMeasurement: currentShowMeasurement, 
								isOnline, 
								isDead 
							} = propsRef.current;
							
							const centerX = 150;
							const baseY = 380;
							const yOffset = -10;
							const armY = yOffset + 136;
							const armStartX = centerX + 5;
							const armLength = 120;
							const sensorX = armStartX + armLength + 10;
							const sensorY = armY + 4;
							
							// Base/Foundation
							p.fill(75, 85, 99);
							p.rect(centerX - 30, baseY - 20, 60, 20, 2);
							p.fill(55, 65, 81);
							p.rect(centerX - 40, baseY - 5, 80, 8);
							
							// Vertical Pole
							p.fill(107, 114, 128);
							p.rect(centerX - 5, yOffset + 70, 10, 30);
							p.fill(156, 163, 175, 127);
							p.rect(centerX - 3, yOffset + 70, 6, 300);
							
							// Solar Panel Support
							p.fill(55, 65, 81);
							p.rect(centerX - 10, yOffset + 90, 20, 4);
							
							// Solar Panel
							p.push();
							p.fill(31, 41, 55);
							p.rect(centerX - 40, yOffset + 50, 80, 40, 2);
							
							// Solar cell grid
							p.stroke(55, 65, 81);
							p.strokeWeight(1);
							for (let i = 1; i < 4; i++) {
								p.line(centerX - 40 + i * 20, yOffset + 50, centerX - 40 + i * 20, yOffset + 90);
							}
							for (let i = 1; i < 3; i++) {
								p.line(centerX - 40, yOffset + 50 + i * 15, centerX + 40, yOffset + 50 + i * 15);
							}
							p.noStroke();
							
							// Solar shine effect
							p.fill(59, 130, 246, 77);
							p.rect(centerX - 40, yOffset + 50, 80, 40, 2);
							p.pop();
							
							// Horizontal Arm (telescopic)
							p.fill(107, 114, 128);
							p.rect(armStartX, armY, armLength, 8);
							p.fill(156, 163, 175, 127);
							p.rect(armStartX, armY + 2, armLength, 4);
							
							// Telescopic segments
							p.fill(124, 124, 124);
							p.rect(armStartX + 20, armY + 1, 100, 6);
							p.fill(140, 140, 140);
							p.rect(armStartX + 40, armY + 2, 80, 4);
							
							// Segment joints
							p.fill(90, 90, 90);
							for (let i = 1; i <= 3; i++) {
								p.rect(armStartX + i * 20, armY, 2, 8);
							}
							
							// Control Box
							p.fill(31, 41, 55);
							p.rect(centerX - 25, yOffset + 110, 50, 60, 3);
							p.fill(17, 24, 39);
							p.rect(centerX - 20, yOffset + 115, 40, 50, 2);
							
							// FLOODBOY text on control box
							p.push();
							p.fill(255, 255, 255, 200);
							p.textAlign(p.CENTER, p.CENTER);
							p.textSize(9);
							p.textStyle(p.BOLD);
							const boxCenterX = centerX;
							p.text('FLOOD', boxCenterX, yOffset + 145);
							p.text('BOY', boxCenterX, yOffset + 157);
							p.textStyle(p.NORMAL);
							p.pop();
							
							// LED indicators
							const time = p.millis() / 1000;
							p.noStroke();
							
							// Status LEDs
							if (isDead) {
								p.fill(239, 68, 68, 204 + Math.sin(time * Math.PI * 2) * 51);
								p.circle(centerX, yOffset + 125, 8);
							} else if (isOnline) {
								p.fill(16, 185, 129, 204 + Math.sin(time * Math.PI) * 51);
								p.circle(centerX - 10, yOffset + 125, 4);
								p.fill(59, 130, 246, 204 + Math.sin(time * Math.PI * 0.8) * 51);
								p.circle(centerX, yOffset + 125, 4);
							} else {
								p.fill(245, 158, 11, 204 + Math.sin(time * Math.PI * 1.5) * 51);
								p.circle(centerX, yOffset + 125, 6);
							}
							
							// Sensor Cylinder
							p.fill(55, 65, 81);
							p.ellipse(sensorX, sensorY, 30, 50);
							p.fill(31, 41, 55);
							p.ellipse(sensorX, sensorY, 24, 44);
							
							// Sensor lens
							p.fill(17, 24, 39);
							p.circle(sensorX, sensorY + 11, 16);
							p.fill(0, 0, 0, 204);
							p.circle(sensorX, sensorY + 11, 12);
							
							// Measurement visualization
							if (currentSensorMode === 'air' && currentShowMeasurement) {
								// Air measurement visualization
								const pulsePhase = (time * 2) % 4;
								const measurementDistance = baseY - 5 - (sensorY + 20);
								
								// Animated measurement pulse
								for (let i = 0; i < 3; i++) {
									const offset = i * 1.2;
									const alpha = Math.max(0, 1 - (pulsePhase + offset) / 4) * 153;
									
									if (alpha > 0) {
										p.stroke(59, 130, 246, alpha);
										p.strokeWeight(2 - i * 0.5);
										
										const pulseProgress = ((pulsePhase + offset) % 4) / 4;
										const startY = sensorY + 20;
										const endY = startY + measurementDistance * Math.min(pulseProgress * 1.2, 1);
										
										p.drawingContext.setLineDash([6, 6]);
										p.line(sensorX, startY, sensorX, endY);
										p.drawingContext.setLineDash([]);
									}
								}
								
								// Distance label
								p.noStroke();
								p.fill(255, 255, 255, 230);
								p.rect(sensorX + 10, armY + 100, 55, 24, 3);
								p.fill(239, 68, 68);
								p.textAlign(p.CENTER, p.CENTER);
								p.textSize(16);
								p.text(currentAirLevel.toFixed(2) + 'm', sensorX + 37.5, armY + 112);
								
							} else if (currentSensorMode === 'water' && currentShowMeasurement) {
								// Water mode
								const waterArea = centerX + 50;
								// Cap water level at installation height for visualization
								const visualWaterLevel = Math.min(currentWaterLevel, currentInstallationHeight);
								const isOverflow = currentWaterLevel > currentInstallationHeight;
								
								// Calculate water Y position - when water level = installation height, water should reach sensor
								// The sensor is at sensorY + 25 (bottom of sensor)
								// Scale factor = distance from base to sensor bottom / installation height
								const sensorBottomY = sensorY + 25;
								const groundY = baseY - 5;
								const totalDistance = groundY - sensorBottomY;
								const scaleFactor = totalDistance / currentInstallationHeight;
								const waterY = groundY - (visualWaterLevel * scaleFactor);
								
								if (currentWaterLevel > 0) {
									// Water surface
									p.noStroke();
									if (isDead) {
										p.fill(239, 68, 68, 102);
									} else if (isOnline) {
										p.fill(59, 130, 246, 102);
									} else {
										p.fill(245, 158, 11, 102);
									}
									p.rect(waterArea, waterY, 150, groundY - waterY);
									
									// Water surface line with wave animation
									if (isDead) {
										p.stroke(239, 68, 68);
									} else if (isOnline) {
										p.stroke(59, 130, 246);
									} else {
										p.stroke(245, 158, 11);
									}
									p.strokeWeight(2);
									p.noFill();
									p.beginShape();
									for (let x = 0; x <= 150; x += 5) {
										const waveY = waterY + Math.sin((x + time * 50) * 0.05) * 2;
										p.vertex(waterArea + x, waveY);
									}
									p.endShape();
									
									// Animated ripples
									for (let i = 0; i < 3; i++) {
										const rippleTime = (time * 1.5 + i * 0.8) % 3;
										const rippleRadius = 5 + rippleTime * 20;
										const rippleAlpha = Math.max(0, 1 - rippleTime / 3) * 77;
										
										if (rippleAlpha > 0) {
											p.noFill();
											if (isDead) {
												p.stroke(239, 68, 68, rippleAlpha);
											} else if (isOnline) {
												p.stroke(59, 130, 246, rippleAlpha);
											} else {
												p.stroke(245, 158, 11, rippleAlpha);
											}
											p.strokeWeight(1.5 - rippleTime * 0.5);
											p.ellipse(sensorX, waterY, rippleRadius * 2, rippleRadius * 0.5);
										}
									}
								} else {
									// Dry floor
									p.noStroke();
									p.fill(139, 115, 85, 204);
									p.rect(waterArea, baseY - 5, 150, 5);
									
									// Floor texture
									p.fill(160, 130, 109, 127);
									for (let x = 0; x < 150; x += 20) {
										p.rect(waterArea + x, baseY - 5, 10, 5);
									}
									
									// Impact waves on dry floor
									for (let i = 0; i < 3; i++) {
										const waveTime = (time * 2 + i * 0.7) % 3;
										const waveRadius = 5 + waveTime * 15;
										const waveAlpha = Math.max(0, 1 - waveTime / 3) * 102;
										
										if (waveAlpha > 0) {
											p.noFill();
											p.stroke(59, 130, 246, waveAlpha);
											p.strokeWeight(2 - waveTime * 0.5);
											p.circle(sensorX, baseY - 5, waveRadius * 2);
										}
									}
								}
								
								// Measurement line
								p.stroke(59, 130, 246, 153);
								p.strokeWeight(1);
								p.drawingContext.setLineDash([4, 4]);
								p.line(sensorX, sensorY + 20, sensorX, currentWaterLevel > 0 ? waterY : baseY - 5);
								p.drawingContext.setLineDash([]);
								
								// Distance label
								p.noStroke();
								if (isDead) {
									p.fill(239, 68, 68);
								} else if (isOnline) {
									p.fill(59, 130, 246);
								} else {
									p.fill(245, 158, 11);
								}
								p.textAlign(p.LEFT, p.CENTER);
								const labelY = visualWaterLevel > 0 ? waterY + 20 : baseY - 30;
								
								// Show actual value with overflow indicator
								if (isOverflow) {
									// Overflow warning - position text more to the right to avoid cropping
									p.fill(239, 68, 68); // Red for warning
									p.textAlign(p.CENTER, p.CENTER);
									
									// Main value with warning icon
									p.text(currentWaterLevel.toFixed(2) + 'm ⚠️', waterArea + 75, labelY);
									
									// Additional warning text below
									p.textSize(10);
									p.text(`Exceeds ${currentInstallationHeight.toFixed(2)}m range`, waterArea + 75, labelY + 15);
									p.textSize(12); // Reset text size
								} else {
									p.text(currentWaterLevel.toFixed(2) + 'm', sensorX + 5, labelY);
								}
							}
							
							// Display installation height and constraint indicators
							if (currentInstallationHeight > 0) {
								// Draw a subtle line showing installation height - directly under the sensor
								p.stroke(156, 163, 175, 100); // Light gray
								p.strokeWeight(1);
								p.drawingContext.setLineDash([2, 2]);
								p.line(sensorX, sensorY + 25, sensorX, baseY - 5);
								p.drawingContext.setLineDash([]);
								
								// Small markers at top and bottom
								p.line(sensorX - 5, sensorY + 25, sensorX + 5, sensorY + 25);
								p.line(sensorX - 5, baseY - 5, sensorX + 5, baseY - 5);
								
								// Draw max water level indicator line (installation height from base)
								// Only show when water level is at or very close to max
								if (currentSensorMode === 'water' && Math.abs(currentWaterLevel - currentInstallationHeight) < 0.01) {
									const waterArea = centerX + 50; // Define waterArea here
									// Use same calculation as water rendering to get the actual water Y position
									const sensorBottomY = sensorY + 25;
									const groundY = baseY - 5;
									const totalDistance = groundY - sensorBottomY;
									const scaleFactor = totalDistance / currentInstallationHeight;
									const waterY = groundY - (currentWaterLevel * scaleFactor);
									
									// Draw MAX indicator at the water surface
									p.stroke(239, 68, 68, 80); // Red line for max water level
									p.strokeWeight(2);
									p.drawingContext.setLineDash([5, 5]);
									p.line(waterArea - 10, waterY, waterArea + 160, waterY);
									p.drawingContext.setLineDash([]);
									
									// Label for max level - positioned below the installation height text
									p.noStroke();
									p.fill(239, 68, 68, 150);
									p.textAlign(p.CENTER, p.CENTER);
									p.textSize(10);
									// Position MAX below the installation height label (which is at sensorY)
									const boxX = sensorX + 20; // Same X as installation height box
									const textWidth = 40; // Same width as installation height box
									p.text('(MAX)', boxX + textWidth/2, sensorY + 15);
								}
								
								p.noStroke();
								
								// Background box for better readability - positioned to fit within canvas
								const textWidth = 40;
								const boxX = sensorX + 20; // Position to the right of sensor
								p.fill(255, 255, 255, 230);
								p.rect(boxX, sensorY - 10, textWidth, 20, 3);
								
								// Installation height text
								p.fill(75, 65, 81); // Dark gray to match sensor color
								p.textAlign(p.CENTER, p.CENTER);
								p.textSize(12);
								p.text(`${currentInstallationHeight.toFixed(2)}m`, boxX + textWidth/2, sensorY);
							}
							
							p.noStroke();
						};
					};

					if (sketchRef.current && !p5InstanceRef.current && typeof window !== 'undefined' && window.p5) {
						p5InstanceRef.current = new window.p5(sketch, sketchRef.current);
					}

					return () => {
						if (p5InstanceRef.current) {
							p5InstanceRef.current.remove();
							p5InstanceRef.current = null;
						}
					};
				}, []);

				React.useEffect(() => {
					if (p5InstanceRef.current) {
						p5InstanceRef.current.redraw();
					}
				}, [waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead]);

				return React.createElement('div', { 
					ref: sketchRef, 
					id: 'p5-container',
					style: { width: '350px', height: '420px', margin: '0 auto' }
				});
			}

			// Main BlockchainApp Component
                        function BlockchainApp() {
                                function getChainConfigForId(chainId) {
                                        switch (chainId) {
                                                case 8899:
                                                        return window.chains.jibchainL1;
                                                case 700011:
                                                        return window.chains.sichang;
                                                case 31337:
                                                        return window.chains.anvil;
                                                default:
                                                        return window.chains.jibchainL1;
                                        }
                                }

                                function getRpcUrlsForChain(chainId) {
                                        const chainConfig = getChainConfigForId(chainId);
                                        if (!chainConfig) return [];

                                        const defaultUrls = chainConfig?.rpcUrls?.default?.http || [];
                                        const publicUrls = chainConfig?.rpcUrls?.public?.http || [];
                                        const combined = [...defaultUrls];

                                        for (const url of publicUrls) {
                                                if (!combined.includes(url)) {
                                                        combined.push(url);
                                                }
                                        }

                                        return combined;
                                }

                                function getRpcUrlForChain(chainId) {
                                        const urls = getRpcUrlsForChain(chainId);
                                        return urls.length > 0 ? urls[0] : null;
                                }

                                async function getClientWithFallback(chainId, { onRpcSelected, performHealthCheck = true } = {}) {
                                        const chainConfig = getChainConfigForId(chainId);
                                        const rpcUrls = getRpcUrlsForChain(chainId);

                                        if (!chainConfig || rpcUrls.length === 0) {
                                                throw new Error('No RPC endpoints configured for this chain.');
                                        }

                                        let lastError = null;

                                        for (const url of rpcUrls) {
                                                try {
                                                        const client = window.viem.createPublicClient({
                                                                chain: chainConfig,
                                                                transport: window.viem.http(url)
                                                        });

                                                        let blockNumber = null;

                                                        if (performHealthCheck) {
                                                                blockNumber = await client.getBlockNumber();
                                                        }

                                                        if (typeof onRpcSelected === 'function') {
                                                                onRpcSelected(url, blockNumber);
                                                        }

                                                        return { client, rpcUrl: url, blockNumber };
                                                } catch (err) {
                                                        lastError = err;
                                                        console.warn(`RPC endpoint failed for chain ${chainId}: ${url}`, err);
                                                }
                                        }

                                        const error = lastError || new Error('Unable to connect to any RPC endpoints.');
                                        throw error;
                                }

                                const [currentChain, setCurrentChain] = React.useState(8899);
                                const [storeData, setStoreData] = React.useState(null);
                                const [isLoading, setIsLoading] = React.useState(true);
                                const [isRefreshing, setIsRefreshing] = React.useState(false);
                                const [activeRpcUrl, setActiveRpcUrl] = React.useState(() => getRpcUrlForChain(8899));
				
				// Helper function to format address
				const formatAddress = (address) => {
					if (!address) return '';
					return `${address.slice(0, 10)}...${address.slice(-6)}`;
				};
				
				// Helper function to get explorer URL based on chain
				const getExplorerUrl = (chainId) => {
					switch(chainId) {
						case 8899:
							return window.chains.jibchainL1.blockExplorers.default.url;
						case 700011:
							return window.chains.sichang.blockExplorers.default.url;
						case 31337:
							return 'http://localhost:8545'; // Local anvil doesn't have a real explorer
						default:
							return window.chains.jibchainL1.blockExplorers.default.url; // Default to JBC
					}
				};
				const [waterLevel, setWaterLevel] = React.useState(0);
				const [temperature, setTemperature] = React.useState(0);
				const [installationHeight, setInstallationHeight] = React.useState(3.0); // Default 3m, will be updated from contract
				const [isOnline, setIsOnline] = React.useState(true);
				const [error, setError] = React.useState(null);
				const [lastUpdated, setLastUpdated] = React.useState(null);
				const [sensorRecords, setSensorRecords] = React.useState([]);
				const [authorizedSensors, setAuthorizedSensors] = React.useState([]);
				const [recentEvents, setRecentEvents] = React.useState([]);
				const [activeTab, setActiveTab] = React.useState('chart'); // 'table' or 'chart' - default to chart
				const chartRef = React.useRef(null);
				const chartInstanceRef = React.useRef(null);
				
				// Block indicator states
				const [blockNumber, setBlockNumber] = React.useState(null);
				const [blockTimer, setBlockTimer] = React.useState(0);
				const [showBlockIndicator, setShowBlockIndicator] = React.useState(true);
				const blockTimerRef = React.useRef(null);
				
				// Enhanced view states
				const [isMaximized, setIsMaximized] = React.useState(false);
				const [showAllRecords, setShowAllRecords] = React.useState(false);
				const [recordsLimit, setRecordsLimit] = React.useState(10); // Default to 10 records
				const [selectedFields, setSelectedFields] = React.useState(['water_depth']); // Default to water depth only
				const [startFromZero, setStartFromZero] = React.useState(true); // Default to start from zero
				const [groupingInterval, setGroupingInterval] = React.useState('3hr'); // Default to 3 hour grouping

				// Aggregate data by time intervals
				const aggregateDataByInterval = React.useCallback((records, interval) => {
					if (!records || records.length === 0 || interval === 'none') return records;
					
					// Helper to round timestamp down to nearest interval boundary
					const roundToInterval = (timestamp) => {
						const date = new Date(timestamp * 1000);
						date.setSeconds(0);
						date.setMilliseconds(0);
						
						switch (interval) {
							case '15min':
								const minutes15 = Math.floor(date.getMinutes() / 15) * 15;
								date.setMinutes(minutes15);
								break;
							case '30min':
								const minutes30 = Math.floor(date.getMinutes() / 30) * 30;
								date.setMinutes(minutes30);
								break;
							case '1hr':
								date.setMinutes(0);
								break;
							case '3hr':
								date.setMinutes(0);
								const hours3 = Math.floor(date.getHours() / 3) * 3;
								date.setHours(hours3);
								break;
							case '6hr':
								date.setMinutes(0);
								const hours6 = Math.floor(date.getHours() / 6) * 6;
								date.setHours(hours6);
								break;
							default:
								return timestamp;
						}
						
						return Math.floor(date.getTime() / 1000);
					};
					
					// Group records by time windows
					const groups = {};
					records.forEach(record => {
						const windowStart = roundToInterval(record.timestamp);
						if (!groups[windowStart]) {
							groups[windowStart] = [];
						}
						groups[windowStart].push(record);
					});
					
					// Aggregate each group
					const aggregatedRecords = Object.entries(groups).map(([windowStart, windowRecords]) => {
						const timestamp = parseInt(windowStart);
						
						// For each field, apply appropriate aggregation
						const aggregatedValues = storeData.fields.map((field, fieldIndex) => {
							const values = windowRecords
								.map(r => r.values[fieldIndex])
								.filter(v => v !== null && v !== undefined);
							
							if (values.length === 0) return null;
							
							// Apply field-specific aggregation strategy
							if (field.name.endsWith('_min')) {
								// For min fields, take the minimum
								return Math.min(...values);
							} else if (field.name.endsWith('_max')) {
								// For max fields, take the maximum
								return Math.max(...values);
							} else if (field.name.endsWith('_count')) {
								// For count fields, sum them
								return values.reduce((sum, val) => sum + val, 0);
							} else if (field.name === 'installation_height') {
								// Installation height is typically constant, take the first value
								return values[0];
							} else {
								// For regular fields (water_depth, battery_voltage, etc.), take average
								const sum = values.reduce((acc, val) => acc + val, 0);
								return sum / values.length;
							}
						});
						
						// Use the first record's metadata as representative
						const representativeRecord = windowRecords[0];
						
						return {
							sensor: representativeRecord.sensor,
							timestamp: timestamp,
							values: aggregatedValues,
							blockNumber: windowRecords[windowRecords.length - 1].blockNumber, // Last block in window
							transactionHash: representativeRecord.transactionHash,
							// Add metadata about aggregation
							aggregated: true,
							recordCount: windowRecords.length,
							originalTimestamps: windowRecords.map(r => r.timestamp)
						};
					});
					
					// Sort by timestamp ascending (for chart display)
					return aggregatedRecords.sort((a, b) => a.timestamp - b.timestamp);
				}, [storeData]);

				// Create chart function
				const createChart = React.useCallback(() => {
					if (!chartRef.current || !sensorRecords.length || !storeData?.fields) return;

					// Always destroy and recreate when selectedFields changes
					// This ensures the chart shows the correct fields
					if (chartInstanceRef.current) {
						chartInstanceRef.current.destroy();
						chartInstanceRef.current = null;
					}

					const ctx = chartRef.current.getContext('2d');
					
					// Prepare data for chart
					const sortedRecords = [...sensorRecords].sort((a, b) => a.timestamp - b.timestamp);
					
					// Apply time interval grouping if enabled
                                        const processedRecords = groupingInterval !== 'none' ?
                                                aggregateDataByInterval(sortedRecords, groupingInterval) :
                                                sortedRecords;

                                        // Filter chart data to only include records from September 9, 2025 onward
                                        const chartCutoffTimestamp = Math.floor(new Date('2025-09-09T00:00:00Z').getTime() / 1000);
                                        const chartRecords = processedRecords.filter(record => record.timestamp >= chartCutoffTimestamp);

                                        // Format labels based on grouping mode
                                        const labels = chartRecords.map(record => {
						const date = new Date(record.timestamp * 1000);
						if (groupingInterval !== 'none') {
							// For grouped data, show cleaner time format
							return date.toLocaleString('en-US', {
								month: 'short',
								day: 'numeric',
								hour: '2-digit',
								minute: '2-digit',
								hour12: false
							});
						}
						return date.toLocaleString();
					});

					// Create datasets - show only selected fields
                                        const hexToRgba = (hex, alpha = 1) => {
                                                const sanitized = hex.replace('#', '');
                                                const bigint = parseInt(sanitized.length === 3
                                                        ? sanitized.split('').map(char => char + char).join('')
                                                        : sanitized, 16);
                                                const r = (bigint >> 16) & 255;
                                                const g = (bigint >> 8) & 255;
                                                const b = bigint & 255;
                                                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                                        };

                                        const waterDepthColor = '#0ea5e9';

                                        const fallbackPalette = [
                                                waterDepthColor, // sky-500
                                                '#2563eb', // blue-600
                                                '#7c3aed', // violet-600
                                                '#16a34a', // green-600
                                                '#f97316', // orange-500
                                                '#ef4444', // red-500
                                                '#14b8a6', // teal-500
                                                '#f59e0b'  // amber-500
                                        ];

                                        const datasets = storeData.fields
						.filter((field, fieldIndex) => {
							// Show only selected fields (not _min, _max, _count variants)
							return selectedFields.includes(field.name) && 
								   !field.name.endsWith('_min') && 
								   !field.name.endsWith('_max') && 
								   !field.name.endsWith('_count');
						})
						.map((field, index) => {
							const fieldIndex = storeData.fields.findIndex(f => f.name === field.name);
                                                        const colors = {
                                                                'water_depth': waterDepthColor, // Sky
                                                                'installation_height': '#16a34a', // Green
                                                                'battery_voltage': '#a855f7', // Purple
                                                        };
                                                        const color = colors[field.name] || fallbackPalette[index % fallbackPalette.length];
							
                                                        const data = chartRecords.map(record => {
								if (record.values[fieldIndex] !== undefined) {
									return parseFloat(formatScaledValue(record.values[fieldIndex], field.unit));
								}
								return null;
							});

							// Format field name for display
							const fieldLabel = field.name.split('_').map(word => 
								word.charAt(0).toUpperCase() + word.slice(1)
							).join(' ');

							return {
								label: `${fieldLabel} (${field.unit.replace(/ x\d+$/, '')})`,
								data: data,
								borderColor: color,
                                                                backgroundColor: hexToRgba(color, 0.15),
                                                                borderWidth: 3,
								tension: 0.4,
								fill: field.name === 'water_depth', // Only fill water depth
								spanGaps: true,
								pointRadius: 2,
								pointHoverRadius: 4,
                                                                pointBackgroundColor: color,
                                                                pointBorderColor: color,
                                                                pointBorderWidth: 1
                                                        };
                                                });

					// Check if this is an update or initial creation
					const isUpdate = chartInstanceRef.current !== null;
					
					chartInstanceRef.current = new Chart(ctx, {
						type: 'line',
						data: {
							labels: labels,
							datasets: datasets
						},
						options: {
							responsive: true,
							maintainAspectRatio: false,
							animation: {
								duration: isUpdate ? 0 : 750 // No animation on updates
							},
							plugins: {
								title: {
									display: true,
									text: (selectedFields.length === 1 && selectedFields[0] === 'water_depth' 
										? 'Water Depth Over Time' 
										: 'Sensor Data Over Time') + (groupingInterval !== 'none' ? ` (${groupingInterval} avg)` : ''),
									font: {
										size: 16,
										weight: '600'
									}
								},
								legend: {
									display: true,
									position: 'top'
								},
								tooltip: {
									callbacks: {
										afterLabel: function(context) {
											// Show aggregation info in tooltip when grouping is enabled
                                                                                        if (groupingInterval !== 'none' && chartRecords[context.dataIndex]) {
                                                                                                const record = chartRecords[context.dataIndex];
												if (record.aggregated && record.recordCount) {
													return `Aggregated from ${record.recordCount} records`;
												}
											}
											return '';
										}
									}
								}
							},
							scales: {
								x: {
									display: true,
									title: {
										display: true,
										text: 'Time'
									},
									ticks: {
										maxTicksLimit: 10
									}
								},
								y: {
									display: true,
									title: {
										display: true,
										text: selectedFields.length === 1 
											? datasets.length > 0 ? datasets[0].label : 'Value'
											: 'Value'
									},
									beginAtZero: startFromZero,
									...(startFromZero ? {} : {
										// For relative scale, add some padding
										grace: '5%'
									})
								}
							},
							interaction: {
								mode: 'index',
								intersect: false,
							}
						}
					});
				}, [sensorRecords, storeData, selectedFields, startFromZero, groupingInterval, aggregateDataByInterval]);

				// Update chart when data changes
				React.useEffect(() => {
					if (activeTab === 'chart' && sensorRecords.length > 0 && selectedFields.length > 0) {
						// Small delay to ensure canvas is ready
						setTimeout(() => {
							createChart();
						}, 100);
					}
					
					// Cleanup on unmount
					return () => {
						if (chartInstanceRef.current) {
							chartInstanceRef.current.destroy();
							chartInstanceRef.current = null;
						}
					};
				}, [activeTab, sensorRecords, selectedFields, createChart, startFromZero, groupingInterval]);

				// Define loadEnhancedStoreData function
				const loadEnhancedStoreData = React.useCallback(async () => {
						// Only set loading on initial load, use refreshing for updates
						if (!storeData) {
							setIsLoading(true);
						} else {
							setIsRefreshing(true);
						}
						setError(null);
						
                                                try {
                                                        const { client: publicClient, rpcUrl, blockNumber: initialBlockNumber } = await getClientWithFallback(
                                                                currentChain,
                                                                {
                                                                        onRpcSelected: (url) => setActiveRpcUrl(url)
                                                                }
                                                        );

                                                        console.log('Loading enhanced data for store:', storeAddress);

                                                        const currentBlockNumber =
                                                                typeof initialBlockNumber === 'bigint'
                                                                        ? initialBlockNumber
                                                                        : await publicClient.getBlockNumber();
                                                        setBlockNumber(currentBlockNumber);

							// Use multicall3 for parallel loading
							const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
							const MULTICALL3_ABI = [
								{
									inputs: [
										{
											components: [
												{ name: 'target', type: 'address' },
												{ name: 'allowFailure', type: 'bool' },
												{ name: 'callData', type: 'bytes' }
											],
											name: 'calls',
											type: 'tuple[]'
										}
									],
									name: 'aggregate3',
									outputs: [
										{
											components: [
												{ name: 'success', type: 'bool' },
												{ name: 'returnData', type: 'bytes' }
											],
											name: 'returnData',
											type: 'tuple[]'
										}
									],
									stateMutability: 'payable',
									type: 'function'
								}
							];
							
							// Import encodeFunctionData from viem
							const { encodeFunctionData, decodeFunctionResult } = window.viem;
							
							// Get factory address for current chain
							const factoryAddress = currentChain === 8899 ? '0x63bB41b79b5aAc6e98C7b35Dcb0fE941b85Ba5Bb' : CONTRACTS[currentChain]?.deployerAddress;
							const DEPLOYER_ABI = pageData.deployerABI;
							console.log('Using factory address:', factoryAddress, 'for chain:', currentChain);
							
							// Prepare multicall
							const calls = [
								{
									target: storeAddress,
									allowFailure: true,
									callData: encodeFunctionData({
										abi: STORE_ABI,
										functionName: 'owner'
									})
								},
								{
									target: storeAddress,
									allowFailure: true,
									callData: encodeFunctionData({
										abi: STORE_ABI,
										functionName: 'getAllFields'
									})
								},
								{
									target: storeAddress,
									allowFailure: true,
									callData: encodeFunctionData({
										abi: STORE_ABI,
										functionName: 'authorizedSignerCount'
									})
								}
							];
							
							// Factory calls are now made directly after multicall
							
							// Execute multicall
							const results = await publicClient.readContract({
								address: MULTICALL3_ADDRESS,
								abi: MULTICALL3_ABI,
								functionName: 'aggregate3',
								args: [calls]
							});
							
							// Decode results
							const owner = results[0].success ? decodeFunctionResult({
								abi: STORE_ABI,
								functionName: 'owner',
								data: results[0].returnData
							}) : null;
							
							const fields = results[1].success ? decodeFunctionResult({
								abi: STORE_ABI,
								functionName: 'getAllFields',
								data: results[1].returnData
							}) : [];
							
							const authorizedSignerCount = results[2].success ? decodeFunctionResult({
								abi: STORE_ABI,
								functionName: 'authorizedSignerCount',
								data: results[2].returnData
							}) : 0;
							
							// Make direct factory calls (only for JIBCHAIN L1 where we know the factory works)
							let nickname = null;
							let description = null;
							let deployedBlockInfo = null;
							let metadata = null;
							
							// Only try factory calls on JIBCHAIN L1 with known factory
							if (factoryAddress && currentChain === 8899 && factoryAddress === '0x63bB41b79b5aAc6e98C7b35Dcb0fE941b85Ba5Bb') {
								console.log('Attempting factory calls for store:', storeAddress);
								console.log('Using factory:', factoryAddress);
								
								// Try storeToNickname first (simplest call)
								try {
									nickname = await publicClient.readContract({
										address: factoryAddress,
										abi: DEPLOYER_ABI,
										functionName: 'storeToNickname',
										args: [storeAddress]
									});
									console.log('✅ Nickname loaded:', nickname);
								} catch (nicknameErr) {
									console.log('❌ storeToNickname failed:', nicknameErr.message);
								}
								
								// Try getStoreMetadata (your Solidity script shows this works)
								try {
									metadata = await publicClient.readContract({
										address: factoryAddress,
										abi: DEPLOYER_ABI,
										functionName: 'getStoreMetadata',
										args: [storeAddress]
									});
									console.log('✅ Metadata loaded:', metadata);
									if (metadata && metadata.length >= 3) {
										// getStoreMetadata returns: [deployedBlock, lastUpdatedBlock, description, pointer]
										deployedBlockInfo = metadata[0];
										description = metadata[2]; // description is at index 2
									}
								} catch (metadataErr) {
									console.log('❌ getStoreMetadata failed:', metadataErr.message);
								}
								
								// Try getStoreInfo as fallback
								try {
									const storeInfo = await publicClient.readContract({
										address: factoryAddress,
										abi: DEPLOYER_ABI,
										functionName: 'getStoreInfo',
										args: [storeAddress]
									});
									console.log('✅ Store info loaded:', storeInfo);
									if (storeInfo && storeInfo.length >= 5) {
										// getStoreInfo returns: [nickname, owner, authorizedSensorCount, deployedBlock, description]
										if (!nickname) nickname = storeInfo[0];
										if (!deployedBlockInfo) deployedBlockInfo = storeInfo[3];
										if (!description) description = storeInfo[4]; // description is at index 4
									}
								} catch (storeInfoErr) {
									console.log('❌ getStoreInfo failed:', storeInfoErr.message);
								}
							} else {
								console.log('Skipping factory calls - not JIBCHAIN L1 or invalid factory address');
							}

							console.log('Store info loaded:', { 
								owner, 
								fields, 
								authorizedSignerCount, 
								nickname,
								description,
								deployedBlockInfo,
								metadata,
								factoryAddress,
								currentChain
							});
							

							// Load ALL events from blockchain
							const currentBlock = await publicClient.getBlockNumber();
							// For production deployment, we know the approximate deployment block
							// This ensures we get ALL historical data without querying unnecessarily far back
							const deploymentBlock = currentChain === 8899 ? BigInt(5900000) : BigInt(0);
							const fromBlock = deploymentBlock; // Get ALL records since deployment

							// Get total records from factory contract
							let totalRecords = 0;
							try {
								// Remove this hardcoded address - use the one from multicall above
								totalRecords = await publicClient.readContract({
									address: factoryAddress,
									abi: [
										{
											"inputs": [{"name": "_store", "type": "address"}],
											"name": "getTotalRecords",
											"outputs": [{"name": "", "type": "uint256"}],
											"stateMutability": "view", 
											"type": "function"
										}
									],
									functionName: 'getTotalRecords',
									args: [storeAddress]
								});
								totalRecords = Number(totalRecords);
								console.log('Total records from factory:', totalRecords);
							} catch (error) {
								console.log('Factory contract not available, using event count fallback:', error.message);
								// Will use processedRecords.length as fallback below
							}

							const eventLogs = await publicClient.getLogs({
								address: storeAddress,
								event: RECORD_STORED_EVENT,
								fromBlock: fromBlock,
								toBlock: 'latest'
							}).catch((err) => {
								console.log('Event loading failed, using fallback:', err.message);
								return [];
							});

							console.log('Event logs loaded:', eventLogs.length, 'events from block', fromBlock.toString(), 'to latest');

							// Process events - get ALL records
							const processedRecords = processRecordLogs(eventLogs);
							
							// Apply smart water level filtering (FloodBoy020 only)
							const filteredRecords = filterWaterLevelData(processedRecords, fields, storeAddress);
							const filteredCount = processedRecords.length - filteredRecords.length;
							if (filteredCount > 0) {
								console.log('Filtered', filteredCount, 'invalid/outlier records from', processedRecords.length, 'total');
							}
							
							const allRecords = filteredRecords; // Use filtered records

							// Get latest record data
							let latestRecord = null;
							let processedData = {};

							if (processedRecords.length > 0) {
								latestRecord = processedRecords[0]; // Most recent
								
								// Process latest values with proper scaling
								fields.forEach((field, index) => {
									if (latestRecord.values[index] !== undefined) {
										const scaledValue = formatScaledValue(latestRecord.values[index], field.unit);
										processedData[field.name] = parseFloat(scaledValue);
									}
								});
							} else {
								// Fallback to direct contract call
								try {
									const [timestamp, values] = await publicClient.readContract({
										address: storeAddress,
										abi: STORE_ABI,
										functionName: 'getLatestRecord',
										args: [owner]
									});

									if (Number(timestamp) > 0) {
										fields.forEach((field, index) => {
											if (values[index] !== undefined) {
												const scaledValue = formatScaledValue(values[index], field.unit);
												processedData[field.name] = parseFloat(scaledValue);
											}
										});
										latestRecord = {
											sensor: owner,
											timestamp: Number(timestamp),
											values: values.map(v => Number(v))
										};
									}
								} catch (directCallErr) {
									console.log('Direct call also failed:', directCallErr.message);
								}
							}

							console.log('Processed latest data:', processedData);

							// Update state with enhanced data
							setStoreData({
								address: storeAddress,
								name: nickname || description || "Sensor Store", // Use nickname first, then description
								nickname: nickname,
								description: description || metadata?.description, // Use description from getStoreInfo first
								pointer: metadata?.pointer,
								deployedBlock: deployedBlockInfo || metadata?.deployedBlock,
								lastUpdatedBlock: metadata?.lastUpdatedBlock,
								owner: owner,
								fields: fields,
								lastTimestamp: latestRecord?.timestamp || 0,
								totalRecords: totalRecords || processedRecords.length
							});

							
							// Only update sensor records if they actually changed
							setSensorRecords(prevRecords => {
								// Check if records are different
								if (prevRecords.length !== allRecords.length) {
									return allRecords;
								}
								
								// Deep comparison without JSON.stringify to handle BigInt
								const hasChanged = prevRecords.some((record, index) => {
									const newRecord = allRecords[index];
									return record.timestamp !== newRecord.timestamp ||
										   record.sensor !== newRecord.sensor ||
										   record.transactionHash !== newRecord.transactionHash ||
										   record.blockNumber !== newRecord.blockNumber ||
										   record.values.some((val, i) => val !== newRecord.values[i]);
								});
								
								if (hasChanged) {
									return allRecords;
								}
								return prevRecords; // Keep the same reference to avoid re-render
							});
							setRecentEvents(eventLogs.slice(0, 5)); // Last 5 events

							// Set sensor values with fallback
							if (processedData.water_depth !== undefined) {
								setWaterLevel(processedData.water_depth);
							} else if (processedData.water_level !== undefined) {
								setWaterLevel(processedData.water_level);
							} else if (processedData.level !== undefined) {
								setWaterLevel(processedData.level);
							}
							
							if (processedData.temperature !== undefined) {
								setTemperature(processedData.temperature);
							} else if (processedData.temp !== undefined) {
								setTemperature(processedData.temp);
							}
							
							// Set installation height if available
							if (processedData.installation_height !== undefined) {
								setInstallationHeight(processedData.installation_height);
							}

							if (latestRecord) {
								setLastUpdated(new Date(latestRecord.timestamp * 1000));
								setIsOnline(true);
							} else {
								setIsOnline(false);
							}

						} catch (err) {
                                                        console.error('Error loading enhanced store data:', err);
                                                        setError(err.message || 'Unable to load store data from available RPC endpoints.');
							// Set fallback data
							setStoreData({
								address: storeAddress,
								name: "Sensor Store (Offline)",
								nickname: null,
								description: null,
								pointer: null,
								deployedBlock: null,
								lastUpdatedBlock: null,
								owner: "Unable to load",
								fields: [],
								lastTimestamp: 0
							});
							setIsOnline(false);
						}
						
						setIsLoading(false);
						setIsRefreshing(false);
				}, [storeAddress]);
				
				// Initial load on mount
				React.useEffect(() => {
					loadEnhancedStoreData();
				}, []);

				// Cleanup chart on unmount
				React.useEffect(() => {
					return () => {
						if (chartInstanceRef.current) {
							chartInstanceRef.current.destroy();
						}
					};
				}, []);

				// Simple block watcher using viem watchBlocks
                                React.useEffect(() => {
                                        let unwatch;
                                        let isMounted = true;

                                        async function setupWatcher() {
                                                if (currentChain !== 8899) {
                                                        return;
                                                }

                                                try {
                                                        const { client: publicClient } = await getClientWithFallback(currentChain, {
                                                                onRpcSelected: (url) => {
                                                                        if (isMounted) {
                                                                                setActiveRpcUrl(url);
                                                                        }
                                                                },
                                                                performHealthCheck: false
                                                        });

                                                        if (!isMounted) {
                                                                return;
                                                        }

                                                        // Use viem's watchBlocks for efficient block monitoring
                                                        unwatch = publicClient.watchBlocks({
                                                                onBlock: async (block) => {
                                                                        setBlockNumber(block.number);

                                                                        // Don't auto-refresh data - let user control when to refresh
                                                                        // This prevents chart from re-rendering constantly
                                                                },
                                                                pollingInterval: 3000, // 3 seconds
                                                        });
                                                } catch (watchError) {
                                                        console.error('Failed to initialize block watcher:', watchError);
                                                }
                                        }

                                        setupWatcher();

                                        return () => {
                                                isMounted = false;
                                                if (unwatch) {
                                                        unwatch();
                                                }
                                        };
                                }, [currentChain]);

				// Handle block timer and visibility for JBC chain
				React.useEffect(() => {
					if (blockNumber !== null && currentChain === 8899) {
						// Reset timer and show indicator when block changes
						setBlockTimer(1);
						setShowBlockIndicator(true);
						
						// Clear existing timer
						if (blockTimerRef.current) {
							clearInterval(blockTimerRef.current);
						}
						
						// Start new timer
						blockTimerRef.current = setInterval(() => {
							setBlockTimer(prev => {
								const newTimer = prev + 1;
								// Hide indicator after 15 seconds
								if (newTimer >= 15) {
									setShowBlockIndicator(false);
									if (blockTimerRef.current) {
										clearInterval(blockTimerRef.current);
									}
								}
								return newTimer;
							});
						}, 1000);
					}
					
					return () => {
						if (blockTimerRef.current) {
							clearInterval(blockTimerRef.current);
						}
					};
				}, [blockNumber, currentChain]);
				
				// Keyboard shortcuts
				React.useEffect(() => {
					const handleKeyPress = (e) => {
						// ESC to exit maximize
						if (e.key === 'Escape' && isMaximized) {
							setIsMaximized(false);
						}
						// F to toggle fullscreen (with modifier key)
						if ((e.key === 'f' || e.key === 'F') && (e.ctrlKey || e.metaKey)) {
							e.preventDefault();
							if (!isMaximized) {
								// When maximizing, default to 100 records
								setRecordsLimit(100);
							}
							setIsMaximized(!isMaximized);
						}
					};
					
					if (typeof window !== 'undefined') {
						window.addEventListener('keydown', handleKeyPress);
						return () => window.removeEventListener('keydown', handleKeyPress);
					}
				}, [isMaximized]);

				// Check for alias resolution error first
				if (pageData.error) {
					return React.createElement('div', { className: 'container mx-auto p-4 sm:p-6' },
						React.createElement('div', { className: 'text-center' },
							React.createElement('div', { className: 'bg-red-50 border border-red-200 rounded-lg p-6 max-w-md mx-auto' },
								React.createElement('h3', { className: 'text-lg font-semibold text-red-800 mb-2' }, 'Invalid Store Alias'),
								React.createElement('p', { className: 'text-red-600 mb-4' }, pageData.error),
								React.createElement('p', { className: 'text-gray-600 text-sm mb-4' }, 
									'The alias you entered does not exist. Please check the URL and try again.'
								),
								React.createElement('a', { 
									href: '/blockchain',
									className: 'inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors'
								}, 'View All Stores'),
								React.createElement('div', { className: 'mt-4' },
									React.createElement('a', { 
										href: '/s/',
										className: 'text-sm text-blue-600 hover:text-blue-800'
									}, 'View Store Directory')
								)
							)
						)
					);
				}

				// Only show loading spinner on initial load when no data exists
				if (isLoading && !storeData) {
					return React.createElement('div', { className: 'container mx-auto p-4 sm:p-6' },
                                                React.createElement('div', { className: 'text-center' },
                                                        React.createElement('div', { className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4' }),
                                                        React.createElement('p', { className: 'text-gray-600' }, 'Loading blockchain data...'),
                                                        React.createElement('p', { className: 'text-gray-500 text-xs mt-2 font-mono' }, activeRpcUrl ? `RPC: ${activeRpcUrl}` : 'RPC: selecting optimal endpoint...'),
                                                        React.createElement('p', { className: 'text-gray-500 text-sm mt-2 font-mono' }, storeAddress)
                                                )
					);
				}

				if (error) {
					return React.createElement('div', { className: 'container mx-auto p-4 sm:p-6' },
						React.createElement('div', { className: 'text-center' },
							React.createElement('div', { className: 'bg-red-50 border border-red-200 rounded-lg p-6 max-w-md mx-auto' },
								React.createElement('h3', { className: 'text-lg font-semibold text-red-800 mb-2' }, 'Connection Error'),
								React.createElement('p', { className: 'text-red-600 mb-4' }, error),
								React.createElement('p', { className: 'text-gray-600 text-sm font-mono' }, storeAddress),
								React.createElement('button', { 
									className: 'mt-4 btn btn-primary',
									onClick: () => window.location.reload()
								}, 'Retry')
							)
						)
					);
				}

				return React.createElement('div', { className: 'container mx-auto p-4 sm:p-6 relative' },
					// Refresh indicator
					isRefreshing && React.createElement('div', { 
						className: 'absolute top-4 right-4 z-10 flex items-center gap-2 bg-gray-800/80 backdrop-blur-sm rounded-lg px-3 py-1.5'
					},
						React.createElement('div', { 
							className: 'animate-spin rounded-full h-4 w-4 border-2 border-gray-600 border-t-purple-400'
						}),
						React.createElement('span', { className: 'text-sm text-gray-400' }, 'Updating...')
					),
					// Back to stores button
					React.createElement('div', { className: 'mb-6' },
						React.createElement('a', { 
							href: '/blockchain',
							className: 'inline-flex items-center text-sm text-gray-600 hover:text-gray-900 transition-colors'
						},
							React.createElement('svg', { 
								className: 'mr-2',
								width: '16',
								height: '16',
								viewBox: '0 0 24 24',
								fill: 'none',
								stroke: 'currentColor',
								strokeWidth: '2'
							},
								React.createElement('path', { d: 'm15 18-6-6 6-6' })
							),
							'Back to all stores'
						)
					),

					// Store Data Section with header inside
					React.createElement('div', { className: 'card border rounded-lg p-6 mb-8' },
						React.createElement('div', { className: 'space-y-4' },
							// Header section inside the box
							React.createElement('div', { className: 'flex items-center justify-between pb-4 border-b' },
								React.createElement('div', {},
									React.createElement('h1', { className: 'text-2xl font-bold text-gray-900 mb-1' }, 
										storeData?.nickname || pageData.aliasInfo?.displayName || 'Public Sensor Store View'
									),
									React.createElement('p', { className: 'text-gray-600 text-sm' }, 
										pageData.aliasInfo ? 'View sensor data stored on the blockchain' : 'View sensor data stored on the blockchain'
									),
									pageData.aliasInfo && React.createElement('p', { className: 'text-xs text-gray-500 mt-1' }, 
										`Alias: /${pageData.aliasInfo.alias}`
									),
									React.createElement('a', { 
										href: `${getExplorerUrl(currentChain)}/address/${storeAddress}`,
										target: '_blank',
										rel: 'noopener noreferrer',
										className: 'text-blue-600 hover:text-blue-700 font-mono text-xs mt-1 block hover:underline'
									}, storeAddress),
								),
								React.createElement('div', { className: 'space-y-2' },
									React.createElement('div', { className: 'flex gap-2' },
										React.createElement('button', { 
											className: 'btn btn-primary text-sm px-3 py-1',
											onClick: () => window.location.reload()
										}, '🔄 Refresh'),
										React.createElement('a', { 
											href: `${getExplorerUrl(currentChain)}/address/${storeAddress}`,
											target: '_blank',
											className: 'btn btn-secondary text-sm px-3 py-1'
										}, '🔗 Explorer')
									),
									React.createElement('div', { className: 'text-xs text-gray-600 space-y-0.5' },
										React.createElement('div', {},
											React.createElement('span', { className: 'font-medium' }, 'Current Block: '),
											React.createElement('span', { className: 'font-mono' }, 
												blockNumber ? Number(blockNumber).toLocaleString() : 'Loading...'
											)
										),
									)
								)
							),
							// Stats grid - 4 columns like production
							React.createElement('div', { className: 'grid grid-cols-2 lg:grid-cols-4 gap-4' },
								// Total Records
								React.createElement('div', { className: 'text-center p-3 bg-gray-50 rounded' },
									React.createElement('div', { className: 'text-2xl font-bold text-blue-600' }, 
										storeData?.totalRecords || sensorRecords?.length || '0'
									),
									React.createElement('div', { className: 'text-sm text-gray-600' }, 'Total Records')
								),
								// Authorized Sensors
								React.createElement('div', { className: 'text-center p-3 bg-gray-50 rounded' },
									React.createElement('div', { className: 'text-2xl font-bold text-green-600' }, '1'),
									React.createElement('div', { className: 'text-sm text-gray-600' }, 'Authorized Sensors')
								),
								// Field Count
								React.createElement('div', { className: 'text-center p-3 bg-gray-50 rounded' },
									React.createElement('div', { className: 'text-2xl font-bold text-purple-600' }, 
										storeData?.fields?.length || '0'
									),
									React.createElement('div', { className: 'text-sm text-gray-600' }, 'Field Count')
								),
								// Owner
								React.createElement('div', { className: 'text-center p-3 bg-gray-50 rounded' },
									React.createElement('div', { className: 'text-sm font-mono text-gray-800' }, 
										storeData?.owner ? `${storeData.owner.slice(0, 6)}...${storeData.owner.slice(-4)}` : 'Loading...'
									),
									React.createElement('div', { className: 'text-sm text-gray-600' }, 'Owner')
								)
							),
							// Description section only (Store Name moved to top)
							storeData?.description && React.createElement('div', { className: 'border-t pt-4 space-y-3' },
								storeData?.description && React.createElement('div', {},
									React.createElement('h3', { className: 'text-sm font-medium text-gray-700 mb-1' }, 'Description'),
									(() => {
										// Parse description for GPS coordinates
										const desc = storeData.description;
										const locMatch = desc.match(/^(.+?)\s+loc:\s*([0-9.-]+),([0-9.-]+)$/);
										
										if (locMatch) {
											const [, location, lat, lng] = locMatch;
											const googleMapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
											
											return React.createElement('div', { className: 'space-y-2' },
												React.createElement('p', { className: 'text-gray-600' }, location.trim()),
												React.createElement('div', { className: 'flex items-center gap-2 text-sm' },
													React.createElement('span', { className: 'text-gray-500' }, 'GPS:'),
													React.createElement('code', { className: 'bg-gray-100 px-2 py-1 rounded text-xs font-mono' }, `${lat}, ${lng}`),
													React.createElement('a', {
														href: googleMapsUrl,
														target: '_blank',
														rel: 'noopener noreferrer',
														className: 'inline-flex items-center text-blue-600 hover:text-blue-700 text-xs'
													}, 
														'View on Google Maps ',
														React.createElement('svg', {
															className: 'w-3 h-3 ml-1',
															fill: 'none',
															viewBox: '0 0 24 24',
															stroke: 'currentColor'
														},
															React.createElement('path', {
																strokeLinecap: 'round',
																strokeLinejoin: 'round',
																strokeWidth: 2,
																d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
															})
														)
													)
												)
											);
										} else {
											return React.createElement('p', { className: 'text-gray-600' }, desc);
										}
									})()
								),
								// Always show description field even if empty for debugging
								!storeData?.description && React.createElement('div', {},
									React.createElement('h3', { className: 'text-sm font-medium text-gray-700 mb-1' }, 'Description'),
									React.createElement('p', { className: 'text-gray-400 italic' }, 'No description available')
								)
							),
							// External link if available
							storeData?.pointer && React.createElement('div', { className: 'border-t pt-4' },
								React.createElement('a', { 
									href: storeData.pointer,
									target: '_blank',
									rel: 'noopener noreferrer',
									className: 'inline-flex items-center text-blue-600 hover:text-blue-700'
								}, 
									'External Reference ↗'
								)
							)
						)
					),
					
					React.createElement('div', { className: 'grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8' },
						// Left Column: Visualization Only
						React.createElement('div', { className: 'card border rounded-lg p-4' },
							React.createElement('h2', { className: 'text-xl font-semibold mb-3' }, 'Sensor Visualization'),
							sensorRecords.length > 0 ? (
								React.createElement('div', {},
									React.createElement('div', { className: 'flex justify-center' },
										React.createElement(FloodboyVisualization, {
											waterLevel: waterLevel,
											airLevel: installationHeight - waterLevel,
											sensorMode: 'water',
											installationHeight: installationHeight,
											showMeasurement: true,
											isOnline: isOnline && lastUpdated && (Date.now() - lastUpdated.getTime()) < 3600000, // Online if data < 1 hour old
											isDead: lastUpdated && (Date.now() - lastUpdated.getTime()) > 86400000 // Dead if data > 24 hours old
										})
									),
									React.createElement('div', { className: 'text-center text-sm mt-2' },
										waterLevel > installationHeight ? 
											React.createElement('span', { className: 'text-red-600 font-medium' },
												`⚠️ Water Level: ${waterLevel.toFixed(2)}m (exceeds ${installationHeight.toFixed(2)}m sensor range)`
											) :
											React.createElement('span', { className: 'text-gray-600' },
												`Current Water Level: ${waterLevel.toFixed(2)}m`
											)
									),
									!isOnline && lastUpdated && React.createElement('div', { className: 'text-center text-sm mt-2 text-orange-600' },
										`Last updated: ${lastUpdated.toLocaleString()}`
									)
								)
							) : (
								React.createElement('div', { className: 'flex flex-col items-center justify-center py-12 text-gray-500' },
									React.createElement('div', { className: 'text-6xl mb-4' }, '📡'),
									React.createElement('h3', { className: 'text-lg font-medium mb-2' }, 'Sensor Not Installed'),
									React.createElement('p', { className: 'text-sm text-center max-w-xs' }, 
										'This sensor has not reported any data yet. Once installed and configured, the visualization will appear here.'
									)
								)
							)
						),
						
						// Right Column: Data Records (Chart/Table) First, then Latest Sensor Data
						React.createElement('div', { className: 'space-y-6' },
							
							// Data Records Section (Chart/Table) - Moved to appear first
							React.createElement(React.Fragment, {},
								// Maximized overlay background - render BEFORE the content
								isMaximized && React.createElement('div', {
									className: 'fixed inset-0 bg-black bg-opacity-50 z-40',									onClick: () => setIsMaximized(false)
								}),
								
								React.createElement('div', { 
									className: `card border rounded-lg p-4 sm:p-6 transition-all duration-300 ${
										isMaximized ? 'fixed inset-4 z-50 bg-white shadow-2xl overflow-auto' : ''
									}`,
									style: isMaximized ? { 
										maxHeight: '90vh',
										animation: 'fadeIn 0.3s ease-out'
									} : {}
								},
									React.createElement('div', { className: 'flex items-center justify-between mb-4' },
									React.createElement('div', {},
										React.createElement('h3', { className: 'text-lg font-semibold flex items-center flex-wrap gap-2' }, 
											React.createElement('span', {}, 'Sensor Data Records'),
											React.createElement('div', { className: 'flex items-center gap-2' },
												sensorRecords.length > 0 && React.createElement('span', { 
													className: 'text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded-full font-normal whitespace-nowrap' 
												}, `${sensorRecords.length} total`),
												activeTab === 'chart' && groupingInterval !== 'none' && sensorRecords.length > 0 && React.createElement('span', { 
													className: 'text-xs px-2 py-1 bg-amber-100 text-amber-700 rounded-full font-normal whitespace-nowrap' 
												}, `→ ${(() => {
													const grouped = aggregateDataByInterval([...sensorRecords].sort((a, b) => a.timestamp - b.timestamp), groupingInterval);
													return `${grouped.length} grouped`;
												})()}`),
												currentChain === 8899 && blockNumber && React.createElement('span', { 
													className: 'inline-flex items-center gap-1 text-xs px-2 py-1 bg-green-100 text-green-700 rounded-full font-normal whitespace-nowrap' 
												},
													React.createElement('span', { 
														className: 'inline-block w-2 h-2 bg-green-500 rounded-full animate-pulse' 
													}),
													'Live'
												)
											)
										),
										React.createElement('p', { className: 'text-sm text-gray-600 flex items-center gap-2' }, 
											`Showing ${showAllRecords ? sensorRecords.length : Math.min(sensorRecords.length, recordsLimit)} records from all sensors`,
											isRefreshing && React.createElement('span', { 
												className: 'inline-flex items-center gap-1 text-xs' 
											},
												React.createElement('span', { 
													className: 'inline-block w-1.5 h-1.5 bg-purple-500 rounded-full animate-pulse' 
												}),
												'Updating...'
											)
										)
									),
									React.createElement('div', { className: 'flex items-center gap-2' },
										React.createElement('button', { 
											className: `btn ${activeTab === 'table' ? 'btn-primary' : 'btn-secondary'}`,
											onClick: () => setActiveTab('table')
										}, '📊 Data Table'),
										React.createElement('button', { 
											className: `btn ${activeTab === 'chart' ? 'btn-primary' : 'btn-secondary'}`,
											onClick: () => setActiveTab('chart')
										}, '📈 Charts'),
										// Only show Export button when maximized
										isMaximized && React.createElement('button', { 
											className: 'btn btn-success',
											onClick: () => {
												// Export visible records
												const recordsToExport = showAllRecords ? sensorRecords : sensorRecords.slice(0, recordsLimit);
												if (recordsToExport.length > 0 && storeData?.fields) {
													const headers = ['Timestamp', 'Block', ...storeData.fields.map(f => f.name), 'Transaction'];
													const rows = recordsToExport.map(record => [
														new Date(record.timestamp * 1000).toISOString(),
														record.blockNumber || '',
														...storeData.fields.map((field, index) => 
															record.values[index] !== undefined ? formatScaledValue(record.values[index], field.unit) : ''
														),
														record.transactionHash || ''
													]);
													const csv = [headers, ...rows].map(row => row.join(',')).join('\\n');
													const blob = new Blob([csv], { type: 'text/csv' });
													const url = URL.createObjectURL(blob);
													const a = document.createElement('a');
													a.href = url;
													a.download = `sensor-data-${storeAddress.slice(0, 8)}-${new Date().toISOString().split('T')[0]}.csv`;
													a.click();
													URL.revokeObjectURL(url);
												}
											}
										}, '💾 Export'),
										React.createElement('button', {
											className: `btn ${isMaximized ? 'btn-warning' : 'btn-secondary'}`,
											onClick: () => {
												if (!isMaximized) {
													// When maximizing, default to 100 records
													setRecordsLimit(100);
												}
												setIsMaximized(!isMaximized);
											},
											title: isMaximized ? 'Exit fullscreen (ESC)' : 'Maximize view (Ctrl+F)'
										}, isMaximized ? '✕ Minimize' : '⛶ Maximize')
									)
								),
								
								// Enhanced statistics when maximized
								isMaximized && sensorRecords.length > 0 && React.createElement('div', { 
									className: 'grid grid-cols-2 md:grid-cols-4 gap-4 mb-4' 
								},
									React.createElement('div', { 
										className: 'bg-blue-50 rounded-lg p-3 cursor-help',
										title: 'Total number of sensor data records stored on blockchain'
									},
										React.createElement('div', { className: 'text-xs text-blue-600 font-medium' }, 'Total Records'),
										React.createElement('div', { className: 'text-2xl font-bold text-blue-700' }, sensorRecords.length)
									),
									React.createElement('div', { className: 'bg-green-50 rounded-lg p-3' },
										React.createElement('div', { className: 'text-xs text-green-600 font-medium' }, 'Time Range'),
										React.createElement('div', { className: 'text-sm font-bold text-green-700' }, 
											sensorRecords.length > 0 ? (() => {
												const oldest = new Date(sensorRecords[sensorRecords.length - 1].timestamp * 1000);
												const newest = new Date(sensorRecords[0].timestamp * 1000);
												const hours = Math.floor((newest - oldest) / (1000 * 60 * 60));
												return hours > 24 ? `${Math.floor(hours / 24)}d ${hours % 24}h` : `${hours}h`;
											})() : '-'
										)
									),
									React.createElement('div', { className: 'bg-purple-50 rounded-lg p-3' },
										React.createElement('div', { className: 'text-xs text-purple-600 font-medium' }, 'Update Frequency'),
										React.createElement('div', { className: 'text-sm font-bold text-purple-700' }, 
											sensorRecords.length > 1 ? (() => {
												// Calculate average time between records
												let totalDiff = 0;
												for (let i = 1; i < Math.min(10, sensorRecords.length); i++) {
													totalDiff += sensorRecords[i-1].timestamp - sensorRecords[i].timestamp;
												}
												const avgSeconds = totalDiff / Math.min(9, sensorRecords.length - 1);
												return avgSeconds < 60 ? `~${Math.round(avgSeconds)}s` : `~${Math.round(avgSeconds / 60)}m`;
											})() : '-'
										)
									),
									React.createElement('div', { className: 'bg-amber-50 rounded-lg p-3' },
										React.createElement('div', { className: 'text-xs text-amber-600 font-medium' }, 'Latest Update'),
										React.createElement('div', { className: 'text-sm font-bold text-amber-700' }, 
											sensorRecords.length > 0 ? (() => {
												const latest = new Date(sensorRecords[0].timestamp * 1000);
												const now = new Date();
												const diffMinutes = Math.floor((now - latest) / (1000 * 60));
												return diffMinutes < 1 ? 'Just now' : 
													   diffMinutes < 60 ? `${diffMinutes}m ago` : 
													   `${Math.floor(diffMinutes / 60)}h ago`;
											})() : '-'
										)
									)
								),
								
								// Show more/less controls when maximized
								isMaximized && sensorRecords.length > 10 && React.createElement('div', { 
									className: 'flex items-center justify-between mb-4 p-3 bg-gray-50 rounded-lg' 
								},
									React.createElement('div', { className: 'flex items-center gap-4' },
										React.createElement('label', { className: 'flex items-center gap-2' },
											React.createElement('input', {
												type: 'checkbox',
												checked: showAllRecords,
												onChange: (e) => setShowAllRecords(e.target.checked),
												className: 'rounded text-blue-600'
											}),
											React.createElement('span', { className: 'text-sm' }, 
												`Show all ${sensorRecords.length} records`
											)
										),
										!showAllRecords && React.createElement('div', { className: 'flex items-center gap-2' },
											React.createElement('label', { className: 'text-sm' }, 'Records per page:'),
											React.createElement('select', {
												value: recordsLimit,
												onChange: (e) => setRecordsLimit(Number(e.target.value)),
												className: 'text-sm border rounded px-2 py-1'
											},
												React.createElement('option', { value: 10 }, '10'),
												React.createElement('option', { value: 25 }, '25'),
												React.createElement('option', { value: 50 }, '50'),
												React.createElement('option', { value: 100 }, '100'),
												React.createElement('option', { value: 250 }, '250'),
												React.createElement('option', { value: 500 }, '500')
											)
										)
									),
									React.createElement('div', { className: 'text-sm text-gray-600' },
										isRefreshing && React.createElement('span', { className: 'flex items-center gap-2' },
											React.createElement('span', { 
												className: 'inline-block w-2 h-2 bg-green-500 rounded-full animate-pulse' 
											}),
											'Live updating...'
										)
									)
								),
								
								// Field selection checkboxes when chart is active
								activeTab === 'chart' && storeData?.fields && React.createElement('div', { 
									className: 'flex flex-wrap items-center justify-between gap-4 mb-4 p-3 bg-gray-50 rounded-lg' 
								},
									React.createElement('div', { className: 'flex flex-wrap gap-3' },
										React.createElement('span', { className: 'text-sm font-medium text-gray-700 self-center mr-2' }, 'Show fields:'),
									storeData.fields
										.filter(field => 
											!field.name.endsWith('_min') && 
											!field.name.endsWith('_max') && 
											!field.name.endsWith('_count')
										)
										.map(field => 
											React.createElement('label', { 
												key: field.name,
												className: `flex items-center gap-2 cursor-pointer px-3 py-2 rounded-lg border-2 transition-all ${
													selectedFields.includes(field.name) 
														? 'bg-blue-100 border-blue-500 text-blue-700' 
														: 'bg-white border-gray-300 text-gray-700 hover:border-gray-400 hover:bg-gray-50'
												}`
											},
												React.createElement('input', {
													type: 'checkbox',
													checked: selectedFields.includes(field.name),
													onChange: (e) => {
														if (e.target.checked) {
															setSelectedFields([...selectedFields, field.name]);
														} else {
															setSelectedFields(selectedFields.filter(f => f !== field.name));
														}
													},
													className: 'w-4 h-4 rounded text-blue-600 focus:ring-blue-500 focus:ring-2'
												}),
												React.createElement('span', { className: 'text-sm font-medium select-none' }, 
													field.name.split('_').map(word => 
														word.charAt(0).toUpperCase() + word.slice(1)
													).join(' ')
												)
											)
										)
									),
									// Scale and grouping toggles
									React.createElement('div', { className: 'flex items-center gap-4' },
										React.createElement('label', { 
											className: `flex items-center gap-2 cursor-pointer px-3 py-2 rounded-lg border-2 transition-all ${
												startFromZero 
													? 'bg-green-100 border-green-500 text-green-700' 
													: 'bg-white border-gray-300 text-gray-700 hover:border-gray-400 hover:bg-gray-50'
											}`
										},
											React.createElement('input', {
												type: 'checkbox',
												checked: startFromZero,
												onChange: (e) => setStartFromZero(e.target.checked),
												className: 'w-4 h-4 rounded text-green-600 focus:ring-green-500 focus:ring-2'
											}),
											React.createElement('span', { className: 'text-sm font-medium select-none' }, 
												'Start Y-axis from 0'
											)
										),
										React.createElement('div', { className: 'flex items-center gap-2' },
											React.createElement('label', { className: 'text-sm font-medium text-gray-700' }, 
												'Group data:'
											),
											React.createElement('select', {
												value: groupingInterval,
												onChange: (e) => setGroupingInterval(e.target.value),
												className: 'text-sm border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500'
											},
												React.createElement('option', { value: 'none' }, 'None'),
												React.createElement('option', { value: '15min' }, '15 minutes'),
												React.createElement('option', { value: '30min' }, '30 minutes'),
												React.createElement('option', { value: '1hr' }, '1 hour'),
												React.createElement('option', { value: '3hr' }, '3 hours'),
												React.createElement('option', { value: '6hr' }, '6 hours')
											)
										),
										React.createElement('button', {
											className: `btn btn-secondary ${isRefreshing ? 'opacity-50 cursor-not-allowed' : ''} ml-2`,
											onClick: () => {
												if (!isRefreshing) {
													loadEnhancedStoreData();
												}
											},
											disabled: isRefreshing,
											title: 'Refresh data'
										}, isRefreshing ? '⟳ Loading...' : '⟳ Refresh')
									)
								),
								
								// Content based on active tab
								React.createElement('div', {},
									activeTab === 'table' ? (
										sensorRecords.length > 0 ? React.createElement('div', { className: 'overflow-x-auto -mx-4 sm:-mx-6' },
											(() => {
												// Filter to only show main fields (exclude _min, _max, _count)
												const allMainFields = storeData?.fields?.filter(field => 
													!field.name.endsWith('_min') && 
													!field.name.endsWith('_max') && 
													!field.name.endsWith('_count')
												) || [];
												
												// Create custom ordered fields: Depth, Height, Voltage
												const fieldOrder = ['water_depth', 'installation_height', 'battery_voltage'];
												const orderedFields = [];
												
												// Add fields in the specified order
												fieldOrder.forEach(fieldName => {
													const field = allMainFields.find(f => f.name === fieldName);
													if (field) {
														orderedFields.push(field);
													}
												});
												
												// Add any remaining fields that weren't in the specified order
												allMainFields.forEach(field => {
													if (!fieldOrder.includes(field.name)) {
														orderedFields.push(field);
													}
												});
												
												return React.createElement('div', { className: 'px-4 sm:px-6' },
													React.createElement('table', { className: 'modern-table w-full' },
													React.createElement('thead', {},
														React.createElement('tr', {},
															React.createElement('th', { className: 'text-left' }, 'Timestamp'),
															...orderedFields.map((field, index) => 
																React.createElement('th', { key: index, className: 'text-right', title: `${field.name} (${field.unit})` }, 
																	// Show full field name when maximized, abbreviated when not
																	isMaximized ? 
																		// Full field name with proper formatting
																		field.name.split('_').map(word => 
																			word.charAt(0).toUpperCase() + word.slice(1)
																		).join(' ') :
																		// Abbreviated - only last word
																		field.name.split('_').pop().charAt(0).toUpperCase() + 
																		field.name.split('_').pop().slice(1)
																)
															),
															React.createElement('th', { className: 'text-right' }, 'Block'),
															React.createElement('th', { className: 'text-right' }, 'Tx Hash')
														)
													),
													React.createElement('tbody', {},
														(showAllRecords ? sensorRecords : sensorRecords.slice(0, recordsLimit)).map((record, recordIndex) => 
															React.createElement('tr', { key: recordIndex },
																React.createElement('td', { className: 'text-sm' }, 
																	(() => {
																		const recordDate = new Date(record.timestamp * 1000);
																		// Always show full date and time when maximized
																		if (isMaximized) {
																			return recordDate.toLocaleString('en-US', {
																				year: 'numeric',
																				month: '2-digit',
																				day: '2-digit',
																				hour: '2-digit',
																				minute: '2-digit',
																				second: '2-digit',
																				hour12: false
																			});
																		}
																		// Original logic for non-maximized view
																		const today = new Date();
																		const isToday = recordDate.toDateString() === today.toDateString();
																		
																		if (isToday) {
																			// Show only time for today's records
																			return recordDate.toLocaleTimeString();
																		} else {
																			// Show full date and time for older records
																			return recordDate.toLocaleString();
																		}
																	})()
																),
																...orderedFields.map((field, fieldIndex) => {
																	// Find the actual index in the original fields array
																	const actualIndex = storeData.fields.findIndex(f => f.name === field.name);
																	return React.createElement('td', { key: fieldIndex, className: 'font-medium text-sm text-right' }, 
																		record.values[actualIndex] !== undefined ? 
																			formatScaledValue(record.values[actualIndex], field.unit) : 
																			'-'
																	);
																}),
																React.createElement('td', { className: 'text-sm text-right' }, 
																	record.blockNumber ? record.blockNumber.toString() : '-'
																),
																React.createElement('td', { className: 'text-sm text-right font-mono' }, 
																	record.transactionHash ? 
																		React.createElement('a', { 
																			href: `${getExplorerUrl(currentChain)}/tx/${record.transactionHash}`,
																			target: '_blank',
																			className: 'text-blue-600 hover:text-blue-800 hover:underline',
																			title: `Transaction: ${record.transactionHash}`
																		}, formatAddress(record.transactionHash))
																		: '-'
																)
															)
														)
													)
												)
												);
											})()
										) : React.createElement('div', { className: 'text-center text-gray-500 py-8' },
											'No sensor data records found'
										)
									) : activeTab === 'chart' ? (
										sensorRecords.length > 0 ? React.createElement('div', { 
											style: { height: '400px', width: '100%', position: 'relative' }
										},
											React.createElement('canvas', { 
												ref: chartRef,
												style: { maxHeight: '400px' }
											})
										) : React.createElement('div', { className: 'text-center text-gray-500 py-8' },
											'No data available for chart'
										)
									) : null
								)
							)
						),
						
						// Latest Sensor Data Section - Moved to appear after Data Records
						React.createElement('div', { className: 'card border rounded-lg p-6' },
							React.createElement('div', { className: 'mb-4' },
								React.createElement('div', { className: 'flex justify-between items-start' },
									React.createElement('div', {},
										React.createElement('h3', { className: 'text-lg font-semibold' }, 'Latest Sensor Data'),
										React.createElement('a', { 
											href: `${getExplorerUrl(currentChain)}/address/${storeAddress}`,
											target: '_blank',
											rel: 'noopener noreferrer',
											className: 'text-sm text-gray-500 hover:text-purple-600 font-mono inline-flex items-center mt-1'
										},
											formatAddress(storeAddress),
											React.createElement('svg', { 
												className: 'w-3 h-3 ml-1',
												fill: 'none',
												stroke: 'currentColor',
												viewBox: '0 0 24 24'
											},
												React.createElement('path', {
													strokeLinecap: 'round',
													strokeLinejoin: 'round',
													strokeWidth: 2,
													d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
												})
											)
										)
									),
									sensorRecords.length > 0 && React.createElement('div', { className: 'text-right' },
									// Block indicator for JBC chain (first line)
									currentChain === 8899 && blockNumber && React.createElement('div', { className: 'flex items-center justify-end' },
										React.createElement('span', { 
											className: `w-2 h-2 ${
												blockTimer >= 10 ? 'bg-yellow-500' : 'bg-green-500'
											} rounded-full mr-2 animate-pulse`
										}),
										React.createElement('span', { className: 'text-sm text-gray-600' }, 'Current Block:'),
										React.createElement('span', { className: 'text-sm font-mono text-purple-600 ml-1' }, 
											blockNumber.toString()
										),
										showBlockIndicator && React.createElement('span', { 
											className: `text-xs ml-1 font-semibold ${
												blockTimer >= 10 ? 'text-yellow-600' : 'text-green-600'
											}`
										}, `(${blockTimer}s)`)
									),
									// Updated timestamp (second line)
									React.createElement('div', { className: 'text-sm text-gray-500 mt-1' },
										lastUpdated ? (() => {
											const today = new Date();
											const isToday = lastUpdated.toDateString() === today.toDateString();
											
											if (isToday) {
												return `Updated: ${lastUpdated.toLocaleTimeString()}`;
											} else {
												return `Updated: ${lastUpdated.toLocaleString()}`;
											}
										})() : ''
									)
								)
								)
							),
							React.createElement('div', { className: 'overflow-x-auto' },
								// Group fields by base name for compact table display
								(() => {
									if (!storeData?.fields || storeData.fields.length === 0) {
										// Fallback display
										return React.createElement('div', { className: 'space-y-3' }, [
											React.createElement('div', { key: 'water', className: 'bg-blue-50 p-4 rounded-lg' },
												React.createElement('div', { className: 'text-sm text-blue-600 font-medium' }, 'Water Level'),
												React.createElement('div', { className: 'text-2xl font-bold text-blue-900' }, `${waterLevel.toFixed(2)} m`)
											),
											React.createElement('div', { key: 'temp', className: 'bg-green-50 p-4 rounded-lg' },
												React.createElement('div', { className: 'text-sm text-green-600 font-medium' }, 'Temperature'),
												React.createElement('div', { className: 'text-2xl font-bold text-green-900' }, `${temperature.toFixed(1)} °C`)
											)
										]);
									}
									
									// Group fields by base name
									const fieldGroups = {};
									
									storeData.fields.forEach((field, index) => {
										// Skip _min, _max, _count fields - we'll collect them under their base name
										if (field.name.endsWith('_min') || field.name.endsWith('_max') || field.name.endsWith('_count')) {
											return;
										}
										
										// This is a main field
										const baseName = field.name;
										
										if (!fieldGroups[baseName]) {
											fieldGroups[baseName] = { baseName, fields: {} };
										}
										
										// Store the main field
										fieldGroups[baseName].fields.main = {
											field,
											index,
											value: sensorRecords.length > 0 && sensorRecords[0].values[index] !== undefined
												? parseFloat(formatScaledValue(sensorRecords[0].values[index], field.unit))
												: null
										};
										
										// Look for related _min, _max, _count fields
										storeData.fields.forEach((relatedField, relatedIndex) => {
											if (relatedField.name === baseName + '_min') {
												fieldGroups[baseName].fields.min = {
													field: relatedField,
													index: relatedIndex,
													value: sensorRecords.length > 0 && sensorRecords[0].values[relatedIndex] !== undefined
														? parseFloat(formatScaledValue(sensorRecords[0].values[relatedIndex], relatedField.unit))
														: null
												};
											} else if (relatedField.name === baseName + '_max') {
												fieldGroups[baseName].fields.max = {
													field: relatedField,
													index: relatedIndex,
													value: sensorRecords.length > 0 && sensorRecords[0].values[relatedIndex] !== undefined
														? parseFloat(formatScaledValue(sensorRecords[0].values[relatedIndex], relatedField.unit))
														: null
												};
											} else if (relatedField.name === baseName + '_count') {
												fieldGroups[baseName].fields.count = {
													field: relatedField,
													index: relatedIndex,
													value: sensorRecords.length > 0 && sensorRecords[0].values[relatedIndex] !== undefined
														? parseFloat(formatScaledValue(sensorRecords[0].values[relatedIndex], relatedField.unit))
														: null
												};
											}
										});
									});
									
									// Convert to array and sort
									const sortedGroups = Object.values(fieldGroups).sort((a, b) => {
										// Priority order for known fields
										const priority = {
											'battery_voltage': 1,
											'installation_height': 2,
											'water_depth': 3,
											'water_level': 4
										};
										return (priority[a.baseName] || 999) - (priority[b.baseName] || 999);
									});
									
									// Render compact table
									return React.createElement('table', { className: 'w-full' },
										React.createElement('thead', {},
											React.createElement('tr', { className: 'border-b' },
												React.createElement('th', { className: 'text-left py-3 px-4 text-sm font-semibold text-gray-700' }, 'Metric'),
												React.createElement('th', { className: 'text-right py-3 px-4 text-sm font-semibold text-gray-700' }, 'Current'),
												React.createElement('th', { className: 'text-right py-3 px-4 text-sm font-semibold text-gray-700' }, 'Min'),
												React.createElement('th', { className: 'text-right py-3 px-4 text-sm font-semibold text-gray-700' }, 'Max')
											)
										),
										React.createElement('tbody', {},
											sortedGroups.map((group, groupIndex) => {
												const main = group.fields.main;
												const min = group.fields.min;
												const max = group.fields.max;
												const count = group.fields.count;
												
												// Clean unit display
												const unit = main.field.unit.replace(/\s*x\s*\d+/gi, '').trim();
												
												// Format display name
												const displayName = group.baseName
													.replace(/_/g, ' ')
													.replace(/\b\w/g, l => l.toUpperCase());
												
												// Color for rows
												const colors = ['bg-blue-50', 'bg-green-50', 'bg-purple-50', 'bg-yellow-50'];
												const rowColor = colors[groupIndex % colors.length];
												
												// Format value helper
												const formatValue = (val, isCount = false) => {
													if (val === null) return 'No data';
													if (isCount || unit.toLowerCase().includes('count')) {
														return `${Math.round(val)}`;
													}
													return val.toFixed(unit.includes('V') ? 3 : unit.includes('m') ? 4 : 2);
												};
												
												// Check if water level exceeds sensor range
												const isWaterLevel = group.baseName.toLowerCase().includes('water');
												const mainValue = main.value;
												const exceedsSensorRange = mainValue !== null && isWaterLevel && mainValue > installationHeight;
												
												return React.createElement('tr', { 
													key: groupIndex,
													className: `${rowColor} ${exceedsSensorRange ? 'bg-red-50' : ''} border-b`
												},
													React.createElement('td', { 
														className: `py-3 px-4 text-sm font-medium ${exceedsSensorRange ? 'text-red-700' : 'text-gray-900'}`
													}, 
														displayName,
														count && React.createElement('span', { 
															className: 'ml-2 px-2 py-1 text-xs font-medium bg-blue-100 text-blue-700 rounded-full'
														}, `${Math.round(count.value)} samples`)
													),
													React.createElement('td', { 
														className: `py-3 px-4 text-right font-bold ${
															mainValue !== null 
																? exceedsSensorRange ? 'text-red-900' : 'text-gray-900' 
																: 'text-gray-400 italic'
														}`
													}, 
														formatValue(mainValue),
														mainValue !== null && ` ${unit}`,
														exceedsSensorRange && ' ⚠️'
													),
													React.createElement('td', { 
														className: `py-3 px-4 text-right text-sm ${
															min?.value !== null ? 'text-gray-700' : 'text-gray-400'
														}`
													}, 
														min ? [
															formatValue(min.value),
															min.value !== null && ` ${unit}`
														] : '—'
													),
													React.createElement('td', { 
														className: `py-3 px-4 text-right text-sm ${
															max?.value !== null ? 'text-gray-700' : 'text-gray-400'
														}`
													}, 
														max ? [
															formatValue(max.value),
															max.value !== null && ` ${unit}`
														] : '—'
													)
												);
											})
										)
									);
								})(),
								
								lastUpdated && React.createElement('div', { className: 'bg-gray-50 p-3 rounded-lg mt-4' },
									React.createElement('div', { className: 'text-xs text-gray-600' }, 'Last Updated'),
									React.createElement('div', { className: 'text-sm font-medium text-gray-800' }, 
										lastUpdated.toLocaleString()
									)
								)
							)
						)
					),

						// Cat Lab inspired sections
						// Field Schema Section (Cat Lab style)
						React.createElement('div', { className: 'card rounded-xl p-6' },
							React.createElement('div', { className: 'flex items-center justify-between mb-4' },
								React.createElement('h3', { className: 'text-lg font-semibold' }, 'Field Schema'),
								React.createElement('div', { className: 'text-sm text-gray-600' }, 
									`${storeData.fields.length} Field${storeData.fields.length !== 1 ? 's' : ''}`
								)
							),
							React.createElement('div', { className: 'text-sm text-gray-600 mb-4' }, 'Data structure and field definitions for this store'),
							React.createElement('div', { className: 'space-y-3' },
								storeData.fields.map((field, index) => 
									React.createElement('div', { 
										key: index, 
										className: 'flex items-center justify-between p-4 bg-gray-50 rounded-lg border-l-4 border-blue-500 hover:shadow-md transition-shadow' 
									},
										React.createElement('div', { className: 'flex items-center gap-4' },
											React.createElement('span', { className: 'font-bold text-gray-700' }, index),
											React.createElement('span', { className: 'font-mono' }, field.name)
										),
										React.createElement('div', { className: 'flex flex-wrap gap-2' },
											React.createElement('span', { 
												className: 'px-2 py-1 bg-blue-600 text-white rounded text-xs font-mono' 
											}, field.unit),
											React.createElement('span', { 
												className: 'px-2 py-1 bg-purple-600 text-white rounded text-xs' 
											}, field.dtype)
										)
									)
								)
							)
						),

					)
				);
			}

			// Render the app
			const root = ReactDOM.createRoot(document.getElementById('blockchain-app'));
			root.render(React.createElement(BlockchainApp));
		</script>
	</body>
</html>
