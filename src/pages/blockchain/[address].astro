---
import BaseHead from '../../components/BaseHead.astro';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../../consts';

// Enable server-side rendering for dynamic routes
export const prerender = false;

// Get the address parameter from the URL
const { address } = Astro.params;
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={`Blockchain Store ${address} | ${SITE_TITLE}`} description={SITE_DESCRIPTION} />
		
		<!-- React and Babel for JSX -->
		<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
		<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
		<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
		
		<!-- p5.js for visualization -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
		
		<!-- Chart.js -->
		<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
		
		<!-- Tailwind CSS -->
		<script src="https://cdn.tailwindcss.com"></script>
		
		<style>
			body {
				margin: 0;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
				background-color: #f9fafb;
				color: #111827;
			}
			
			/* P5 Container Styling for light theme */
			#p5-container {
				border-radius: 12px;
				overflow: hidden;
				transition: all 0.3s ease;
				border: 2px solid #d1d5db;
				background: rgba(255, 255, 255, 0.95);
				box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
			}
			
			/* Card Styling for light theme */
			.card {
				background-color: #ffffff;
				border-color: #e5e7eb;
				box-shadow: 0 4px 6px rgba(0, 0, 0, 0.05);
			}
			
			/* Button Styling */
			.btn-primary {
				background-color: #7c3aed;
				color: white;
			}
			.btn-primary:hover {
				background-color: #6d28d9;
			}
			.btn-secondary {
				background-color: #f3f4f6;
				color: #374151;
			}
			.btn-secondary:hover {
				background-color: #e5e7eb;
			}
			
			/* Input Styling for light theme */
			.input {
				background-color: #f9fafb;
				border-color: #d1d5db;
				color: #111827;
			}
			.input::placeholder {
				color: #6b7280;
			}
			
			.loading-skeleton {
				animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
				background-color: #e5e7eb;
			}
			@keyframes pulse {
				0%, 100% { opacity: 1; }
				50% { opacity: .5; }
			}
		</style>
	</head>
	<body class="light">
		<Header />
		<main>
			<div id="blockchain-app"></div>
		</main>
		<Footer />

		<script type="module">
			// Import viem modules
			import { createPublicClient, http, parseAbi, formatEther, decodeEventLog } from 'https://esm.sh/viem@2.21.19';
			import { mainnet, sepolia, anvil } from 'https://esm.sh/viem@2.21.19/chains';
			
			// Custom chain configurations
			const jibchainL1 = {
				id: 8899,
				name: 'JIBCHAIN L1',
				network: 'jibchain',
				nativeCurrency: { name: 'JBC', symbol: 'JBC', decimals: 18 },
				rpcUrls: {
					default: { http: ['https://rpc-l1.jbc.xpool.pw'] },
					public: { http: ['https://rpc-l1.jbc.xpool.pw'] }
				},
				blockExplorers: {
					default: { name: 'JBC Explorer', url: 'https://exp.jibchain.net' }
				}
			};
			
			const sichang = {
				id: 700011,
				name: 'SiChang',
				network: 'sichang',
				nativeCurrency: { name: 'TCH', symbol: 'TCH', decimals: 18 },
				rpcUrls: {
					default: { http: ['https://sichang-rpc.thaichain.org'] },
					public: { http: ['https://sichang-rpc.thaichain.org'] }
				},
				blockExplorers: {
					default: { name: 'SiChang Explorer', url: 'https://sichang.thaichain.org' }
				}
			};
			
			// Make viem and chains available globally
			window.viem = { createPublicClient, http, parseAbi, formatEther, decodeEventLog };
			window.chains = { mainnet, sepolia, anvil, jibchainL1, sichang };

			// Get the address from the URL path
			const urlParts = window.location.pathname.split('/');
			const storeAddress = urlParts[urlParts.length - 1]; // Get the address parameter

			// Contract ABIs and configurations
			const CONTRACTS = {
				31337: {
					DEPLOYER_ADDRESS: "0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9",
					EXPLORER_URL: "http://localhost:8545",
				},
				700011: {
					DEPLOYER_ADDRESS: "0x0000000000000000000000000000000000000000",
					EXPLORER_URL: "https://sichang.thaichain.org",
				},
				8899: {
					DEPLOYER_ADDRESS: "0x5cEe5489DdB5006e5c1c1f2029bc7451E4A25837",
					EXPLORER_URL: "https://exp.jibchain.net",
				},
			};

			const STORE_ABI = [
				{
					"inputs": [],
					"name": "getAllFields",
					"outputs": [{"components": [{"internalType": "string", "name": "name", "type": "string"}, {"internalType": "string", "name": "unit", "type": "string"}, {"internalType": "string", "name": "dtype", "type": "string"}], "internalType": "struct SecureSensorStore.Field[]", "name": "", "type": "tuple[]"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [{"internalType": "address", "name": "sensor", "type": "address"}],
					"name": "getLatestRecord",
					"outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}, {"internalType": "int256[]", "name": "", "type": "int256[]"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [],
					"name": "owner",
					"outputs": [{"internalType": "address", "name": "", "type": "address"}],
					"stateMutability": "view",
					"type": "function"
				}
			];

			// FloodboyVisualization React Component (inline)
			function FloodboyVisualization({ waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead }) {
				const sketchRef = React.useRef(null);
				const p5InstanceRef = React.useRef(null);
				const propsRef = React.useRef({ waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead });

				// Update props ref
				React.useEffect(() => {
					propsRef.current = { waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead };
				}, [waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead]);

				React.useEffect(() => {
					const sketch = (p) => {
						p.setup = () => {
							const canvas = p.createCanvas(350, 420);
							canvas.parent(sketchRef.current);
							p.frameRate(30);
						};

						p.draw = () => {
							p.clear();
							p.background(255, 255, 255, 0);
							
							const { 
								waterLevel: currentWaterLevel, 
								airLevel: currentAirLevel, 
								sensorMode: currentSensorMode, 
								installationHeight: currentInstallationHeight, 
								showMeasurement: currentShowMeasurement, 
								isOnline, 
								isDead 
							} = propsRef.current;
							
							const centerX = 150;
							const baseY = 380;
							const yOffset = -10;
							const armY = yOffset + 136;
							const armStartX = centerX + 5;
							const armLength = 120;
							const sensorX = armStartX + armLength + 10;
							const sensorY = armY + 4;
							
							// Base/Foundation
							p.fill(75, 85, 99);
							p.rect(centerX - 30, baseY - 20, 60, 20, 2);
							p.fill(55, 65, 81);
							p.rect(centerX - 40, baseY - 5, 80, 8);
							
							// Vertical Pole
							p.fill(107, 114, 128);
							p.rect(centerX - 5, yOffset + 70, 10, 30);
							p.fill(156, 163, 175, 127);
							p.rect(centerX - 3, yOffset + 70, 6, 300);
							
							// Solar Panel Support
							p.fill(55, 65, 81);
							p.rect(centerX - 10, yOffset + 90, 20, 4);
							
							// Solar Panel
							p.push();
							p.fill(31, 41, 55);
							p.rect(centerX - 40, yOffset + 50, 80, 40, 2);
							
							// Solar cell grid
							p.stroke(55, 65, 81);
							p.strokeWeight(1);
							for (let i = 1; i < 4; i++) {
								p.line(centerX - 40 + i * 20, yOffset + 50, centerX - 40 + i * 20, yOffset + 90);
							}
							for (let i = 1; i < 3; i++) {
								p.line(centerX - 40, yOffset + 50 + i * 15, centerX + 40, yOffset + 50 + i * 15);
							}
							p.noStroke();
							
							// Solar shine effect
							p.fill(59, 130, 246, 77);
							p.rect(centerX - 40, yOffset + 50, 80, 40, 2);
							p.pop();
							
							// Horizontal Arm (telescopic)
							p.fill(107, 114, 128);
							p.rect(armStartX, armY, armLength, 8);
							p.fill(156, 163, 175, 127);
							p.rect(armStartX, armY + 2, armLength, 4);
							
							// Telescopic segments
							p.fill(124, 124, 124);
							p.rect(armStartX + 20, armY + 1, 100, 6);
							p.fill(140, 140, 140);
							p.rect(armStartX + 40, armY + 2, 80, 4);
							
							// Segment joints
							p.fill(90, 90, 90);
							for (let i = 1; i <= 3; i++) {
								p.rect(armStartX + i * 20, armY, 2, 8);
							}
							
							// Control Box
							p.fill(31, 41, 55);
							p.rect(centerX - 25, yOffset + 110, 50, 60, 3);
							p.fill(17, 24, 39);
							p.rect(centerX - 20, yOffset + 115, 40, 50, 2);
							
							// FLOODBOY text on control box
							p.push();
							p.fill(255, 255, 255, 200);
							p.textAlign(p.CENTER, p.CENTER);
							p.textSize(9);
							p.textStyle(p.BOLD);
							const boxCenterX = centerX;
							p.text('FLOOD', boxCenterX, yOffset + 145);
							p.text('BOY', boxCenterX, yOffset + 157);
							p.textStyle(p.NORMAL);
							p.pop();
							
							// LED indicators
							const time = p.millis() / 1000;
							p.noStroke();
							
							// Status LEDs
							if (isDead) {
								p.fill(239, 68, 68, 204 + Math.sin(time * Math.PI * 2) * 51);
								p.circle(centerX, yOffset + 125, 8);
							} else if (isOnline) {
								p.fill(16, 185, 129, 204 + Math.sin(time * Math.PI) * 51);
								p.circle(centerX - 10, yOffset + 125, 4);
								p.fill(59, 130, 246, 204 + Math.sin(time * Math.PI * 0.8) * 51);
								p.circle(centerX, yOffset + 125, 4);
							} else {
								p.fill(245, 158, 11, 204 + Math.sin(time * Math.PI * 1.5) * 51);
								p.circle(centerX, yOffset + 125, 6);
							}
							
							// Sensor Cylinder
							p.fill(55, 65, 81);
							p.ellipse(sensorX, sensorY, 30, 50);
							p.fill(31, 41, 55);
							p.ellipse(sensorX, sensorY, 24, 44);
							
							// Sensor lens
							p.fill(17, 24, 39);
							p.circle(sensorX, sensorY + 11, 16);
							p.fill(0, 0, 0, 204);
							p.circle(sensorX, sensorY + 11, 12);
							
							// Water visualization for water mode
							if (currentSensorMode === 'water' && currentShowMeasurement) {
								const waterArea = centerX + 50;
								const sensorBottomY = sensorY + 25;
								const groundY = baseY - 5;
								const totalDistance = groundY - sensorBottomY;
								const scaleFactor = totalDistance / currentInstallationHeight;
								const waterY = groundY - (currentWaterLevel * scaleFactor);
								
								if (currentWaterLevel > 0) {
									// Water surface
									p.noStroke();
									if (isDead) {
										p.fill(239, 68, 68, 102);
									} else if (isOnline) {
										p.fill(59, 130, 246, 102);
									} else {
										p.fill(245, 158, 11, 102);
									}
									p.rect(waterArea, waterY, 150, groundY - waterY);
									
									// Water surface line with wave animation
									if (isDead) {
										p.stroke(239, 68, 68);
									} else if (isOnline) {
										p.stroke(59, 130, 246);
									} else {
										p.stroke(245, 158, 11);
									}
									p.strokeWeight(2);
									p.noFill();
									p.beginShape();
									for (let x = 0; x <= 150; x += 5) {
										const waveY = waterY + Math.sin((x + time * 50) * 0.05) * 2;
										p.vertex(waterArea + x, waveY);
									}
									p.endShape();
									
									// Animated ripples
									for (let i = 0; i < 3; i++) {
										const rippleTime = (time * 1.5 + i * 0.8) % 3;
										const rippleRadius = 5 + rippleTime * 20;
										const rippleAlpha = Math.max(0, 1 - rippleTime / 3) * 77;
										
										if (rippleAlpha > 0) {
											p.noFill();
											if (isDead) {
												p.stroke(239, 68, 68, rippleAlpha);
											} else if (isOnline) {
												p.stroke(59, 130, 246, rippleAlpha);
											} else {
												p.stroke(245, 158, 11, rippleAlpha);
											}
											p.strokeWeight(1.5 - rippleTime * 0.5);
											p.ellipse(sensorX, waterY, rippleRadius * 2, rippleRadius * 0.5);
										}
									}
								}
								
								// Measurement line
								p.stroke(59, 130, 246, 153);
								p.strokeWeight(1);
								p.drawingContext.setLineDash([4, 4]);
								p.line(sensorX, sensorY + 20, sensorX, currentWaterLevel > 0 ? waterY : baseY - 5);
								p.drawingContext.setLineDash([]);
								
								// Distance label
								p.noStroke();
								if (isDead) {
									p.fill(239, 68, 68);
								} else if (isOnline) {
									p.fill(59, 130, 246);
								} else {
									p.fill(245, 158, 11);
								}
								p.textAlign(p.LEFT, p.CENTER);
								const labelY = currentWaterLevel > 0 ? waterY + 20 : baseY - 30;
								p.text(currentWaterLevel.toFixed(2) + 'm', sensorX + 5, labelY);
							}
							
							p.noStroke();
						};
					};

					if (sketchRef.current && !p5InstanceRef.current && typeof window !== 'undefined' && window.p5) {
						p5InstanceRef.current = new window.p5(sketch, sketchRef.current);
					}

					return () => {
						if (p5InstanceRef.current) {
							p5InstanceRef.current.remove();
							p5InstanceRef.current = null;
						}
					};
				}, []);

				React.useEffect(() => {
					if (p5InstanceRef.current) {
						p5InstanceRef.current.redraw();
					}
				}, [waterLevel, airLevel, sensorMode, installationHeight, showMeasurement, isOnline, isDead]);

				return React.createElement('div', { 
					ref: sketchRef, 
					id: 'p5-container',
					style: { width: '350px', height: '420px', margin: '0 auto' }
				});
			}

			// Main BlockchainApp Component
			function BlockchainApp() {
				const [currentChain, setCurrentChain] = React.useState(8899);
				const [storeData, setStoreData] = React.useState(null);
				const [isLoading, setIsLoading] = React.useState(true);
				const [waterLevel, setWaterLevel] = React.useState(0);
				const [temperature, setTemperature] = React.useState(0);
				const [isOnline, setIsOnline] = React.useState(true);
				const [error, setError] = React.useState(null);
				const [lastUpdated, setLastUpdated] = React.useState(null);

				// Load real data from blockchain
				React.useEffect(() => {
					async function loadRealStoreData() {
						setIsLoading(true);
						setError(null);
						
						try {
							// Create public client for JIBCHAIN L1
							const publicClient = window.viem.createPublicClient({
								chain: window.chains.jibchainL1,
								transport: window.viem.http()
							});

							console.log('Loading data for store:', storeAddress);

							// Get store owner
							const owner = await publicClient.readContract({
								address: storeAddress,
								abi: STORE_ABI,
								functionName: 'owner'
							});

							// Get all fields to understand the store structure
							const fields = await publicClient.readContract({
								address: storeAddress,
								abi: STORE_ABI,
								functionName: 'getAllFields'
							});

							console.log('Store fields:', fields);

							// Get latest record from the store owner (assuming owner is also a sensor)
							const [timestamp, values] = await publicClient.readContract({
								address: storeAddress,
								abi: STORE_ABI,
								functionName: 'getLatestRecord',
								args: [owner]
							});

							console.log('Latest record:', { timestamp, values });

							// Process the values based on field definitions
							let processedData = {};
							fields.forEach((field, index) => {
								if (values[index] !== undefined) {
									// Convert from scaled integer to float (assuming 2 decimal places)
									const value = Number(values[index]) / 100;
									processedData[field.name] = value;
								}
							});

							console.log('Processed data:', processedData);

							// Update state with real data
							setStoreData({
								address: storeAddress,
								name: "Floodboy Sensor Store",
								owner: owner,
								fields: fields,
								lastTimestamp: Number(timestamp)
							});

							// Set sensor values
							if (processedData.water_level !== undefined) {
								setWaterLevel(processedData.water_level);
							}
							if (processedData.temperature !== undefined) {
								setTemperature(processedData.temperature);
							}

							setLastUpdated(new Date(Number(timestamp) * 1000));
							setIsOnline(true);

						} catch (err) {
							console.error('Error loading store data:', err);
							setError(err.message);
							// Set fallback data
							setStoreData({
								address: storeAddress,
								name: "Floodboy Sensor Store (Offline)",
								owner: "Unable to load",
								fields: [],
								lastTimestamp: 0
							});
							setIsOnline(false);
						}
						
						setIsLoading(false);
					}

					loadRealStoreData();
					
					// Set up polling for real-time updates every 30 seconds
					const interval = setInterval(loadRealStoreData, 30000);
					return () => clearInterval(interval);
				}, []);

				if (isLoading) {
					return React.createElement('div', { className: 'container mx-auto p-6' },
						React.createElement('div', { className: 'text-center' },
							React.createElement('div', { className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4' }),
							React.createElement('p', { className: 'text-gray-600' }, 'Loading blockchain data...'),
							React.createElement('p', { className: 'text-gray-500 text-sm mt-2 font-mono' }, storeAddress)
						)
					);
				}

				if (error) {
					return React.createElement('div', { className: 'container mx-auto p-6' },
						React.createElement('div', { className: 'text-center' },
							React.createElement('div', { className: 'bg-red-50 border border-red-200 rounded-lg p-6 max-w-md mx-auto' },
								React.createElement('h3', { className: 'text-lg font-semibold text-red-800 mb-2' }, 'Connection Error'),
								React.createElement('p', { className: 'text-red-600 mb-4' }, error),
								React.createElement('p', { className: 'text-gray-600 text-sm font-mono' }, storeAddress),
								React.createElement('button', { 
									className: 'mt-4 px-4 py-2 bg-red-600 text-white rounded hover:bg-red-700 transition',
									onClick: () => window.location.reload()
								}, 'Retry')
							)
						)
					);
				}

				return React.createElement('div', { className: 'container mx-auto p-6' },
					React.createElement('div', { className: 'mb-8' },
						React.createElement('h1', { className: 'text-3xl font-bold text-gray-900 mb-2' }, 'Floodboy Blockchain Store'),
						React.createElement('p', { className: 'text-gray-600 font-mono text-sm' }, storeAddress)
					),
					
					React.createElement('div', { className: 'grid grid-cols-1 lg:grid-cols-2 gap-8' },
						// Visualization Column
						React.createElement('div', { className: 'card border rounded-lg p-6' },
							React.createElement('h2', { className: 'text-xl font-semibold mb-4' }, 'Sensor Visualization'),
							React.createElement('div', { className: 'flex justify-center mb-4' },
								React.createElement(FloodboyVisualization, {
									waterLevel: waterLevel,
									airLevel: 2.5 - waterLevel,
									sensorMode: 'water',
									installationHeight: 2.5,
									showMeasurement: true,
									isOnline: isOnline,
									isDead: false
								})
							),
							React.createElement('div', { className: 'text-center text-sm text-gray-600' },
								`Current Water Level: ${waterLevel.toFixed(2)}m`
							)
						),
						
						// Store Info Column
						React.createElement('div', { className: 'space-y-6' },
							React.createElement('div', { className: 'card border rounded-lg p-6' },
								React.createElement('h3', { className: 'text-lg font-semibold mb-4' }, 'Store Information'),
								React.createElement('div', { className: 'space-y-3' },
									React.createElement('div', { className: 'flex justify-between' },
										React.createElement('span', { className: 'text-gray-600' }, 'Network:'),
										React.createElement('span', { className: 'font-medium' }, 'JIBCHAIN L1')
									),
									React.createElement('div', { className: 'flex justify-between' },
										React.createElement('span', { className: 'text-gray-600' }, 'Chain ID:'),
										React.createElement('span', { className: 'font-medium' }, '8899')
									),
									React.createElement('div', { className: 'flex justify-between' },
										React.createElement('span', { className: 'text-gray-600' }, 'Owner:'),
										React.createElement('span', { className: 'font-medium font-mono text-xs' }, 
											storeData?.owner ? 
												`${storeData.owner.slice(0, 6)}...${storeData.owner.slice(-4)}` : 
												'Loading...'
										)
									),
									React.createElement('div', { className: 'flex justify-between' },
										React.createElement('span', { className: 'text-gray-600' }, 'Status:'),
										React.createElement('span', { 
											className: `font-medium ${isOnline ? 'text-green-600' : 'text-red-600'}` 
										}, isOnline ? 'Online' : 'Offline')
									),
									React.createElement('div', { className: 'flex justify-between' },
										React.createElement('span', { className: 'text-gray-600' }, 'Fields:'),
										React.createElement('span', { className: 'font-medium' }, 
											storeData?.fields ? storeData.fields.length : '0'
										)
									)
								)
							),
							
							React.createElement('div', { className: 'card border rounded-lg p-6' },
								React.createElement('h3', { className: 'text-lg font-semibold mb-4' }, 'Latest Sensor Data'),
								React.createElement('div', { className: 'space-y-3' },
									React.createElement('div', { className: 'bg-blue-50 p-4 rounded-lg' },
										React.createElement('div', { className: 'text-sm text-blue-600 font-medium' }, 'Water Level'),
										React.createElement('div', { className: 'text-2xl font-bold text-blue-900' }, `${waterLevel.toFixed(2)} m`)
									),
									React.createElement('div', { className: 'bg-green-50 p-4 rounded-lg' },
										React.createElement('div', { className: 'text-sm text-green-600 font-medium' }, 'Temperature'),
										React.createElement('div', { className: 'text-2xl font-bold text-green-900' }, `${temperature.toFixed(1)} °C`)
									),
									lastUpdated && React.createElement('div', { className: 'bg-gray-50 p-3 rounded-lg' },
										React.createElement('div', { className: 'text-xs text-gray-600' }, 'Last Updated'),
										React.createElement('div', { className: 'text-sm font-medium text-gray-800' }, 
											lastUpdated.toLocaleString()
										)
									)
								)
							),
							
							React.createElement('div', { className: 'card border rounded-lg p-6' },
								React.createElement('h3', { className: 'text-lg font-semibold mb-4' }, 'Data Source'),
								React.createElement('div', { className: 'space-y-3' },
									React.createElement('div', { className: 'bg-yellow-50 p-4 rounded-lg border border-yellow-200' },
										React.createElement('div', { className: 'text-sm text-yellow-800 font-medium mb-2' }, '📊 Live Blockchain Data'),
										React.createElement('div', { className: 'text-xs text-yellow-700' }, 
											'Data automatically refreshes every 30 seconds from the blockchain'
										)
									),
									React.createElement('div', { className: 'flex justify-between items-center' },
										React.createElement('span', { className: 'text-sm text-gray-600' }, 'Auto Refresh:'),
										React.createElement('span', { className: 'text-sm font-medium text-green-600' }, 'Enabled')
									),
									storeData?.fields && storeData.fields.length > 0 && React.createElement('div', {},
										React.createElement('div', { className: 'text-sm font-medium text-gray-700 mb-2' }, 'Available Fields:'),
										React.createElement('div', { className: 'space-y-1' },
											storeData.fields.map((field, index) => 
												React.createElement('div', { 
													key: index, 
													className: 'text-xs bg-gray-100 p-2 rounded flex justify-between' 
												},
													React.createElement('span', { className: 'font-mono' }, field.name),
													React.createElement('span', { className: 'text-gray-500' }, `${field.dtype} (${field.unit})`)
												)
											)
										)
									)
								)
							)
						)
					)
				);
			}

			// Render the app
			const root = ReactDOM.createRoot(document.getElementById('blockchain-app'));
			root.render(React.createElement(BlockchainApp));
		</script>
	</body>
</html>