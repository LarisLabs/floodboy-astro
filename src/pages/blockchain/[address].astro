---
import BaseHead from '../../components/BaseHead.astro';
import Header from '../../components/Header.astro';
import Footer from '../../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../../consts';
import { BLOCKCHAIN_CONFIG } from '../../config/blockchain.config';
import { getAddressFromAlias, getAliasFromAddress, STORE_ALIASES } from '../../config/aliases.config';
import { CatLabSensorStoreABI, CatLabFactoryABI } from '../../abis';
import { DEPLOYER_ABI } from '../../utils/blockchain-constants';

// Enable server-side rendering for dynamic routes
export const prerender = false;

// Get the address parameter from the URL
const { address: addressOrAlias } = Astro.params;

// Validate Ethereum address format
const isEthereumAddress = /^0x[a-fA-F0-9]{40}$/i.test(addressOrAlias);

let resolvedAddress = addressOrAlias;
let aliasInfo = null;
let error = null;

if (!isEthereumAddress) {
  // Try to resolve as alias
  const addressFromAlias = getAddressFromAlias(addressOrAlias);
  if (addressFromAlias) {
    resolvedAddress = addressFromAlias;
    // Find the full alias info
    const storeAlias = STORE_ALIASES.find(a => a.alias.toLowerCase() === addressOrAlias.toLowerCase());
    if (storeAlias) {
      aliasInfo = {
        alias: storeAlias.alias,
        displayName: storeAlias.displayName
      };
    }
  } else {
    error = `Invalid alias: ${addressOrAlias}`;
    resolvedAddress = null;
  }
} else {
  // Check if this address has an alias
  const alias = getAliasFromAddress(addressOrAlias);
  if (alias) {
    const storeAlias = STORE_ALIASES.find(a => a.address.toLowerCase() === addressOrAlias.toLowerCase());
    if (storeAlias) {
      aliasInfo = {
        alias: storeAlias.alias,
        displayName: storeAlias.displayName
      };
    }
  }
}

// Prepare data for client-side
const pageData = {
  originalParam: addressOrAlias,
  address: resolvedAddress,
  aliasInfo: aliasInfo,
  error: error,
  storeABI: CatLabSensorStoreABI,
  factoryABI: CatLabFactoryABI,
  deployerABI: DEPLOYER_ABI
};

// Prepare configuration for injection
const configJson = JSON.stringify(BLOCKCHAIN_CONFIG);
const pageDataJson = JSON.stringify(pageData);

// Update page title based on alias or address
const pageTitle = aliasInfo 
  ? `${aliasInfo.displayName} | ${SITE_TITLE}`
  : `Blockchain Store ${addressOrAlias} | ${SITE_TITLE}`;
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={pageTitle} description={SITE_DESCRIPTION} />
		
		<!-- React and Babel for JSX -->
		<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
		<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
		<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
		
		<!-- p5.js for visualization -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>

		<!-- Blockchain utilities (bundled by Astro) -->
		<script>
			import '../../scripts/blockchain-page.ts';
		</script>
		
		<!-- Chart.js with proper module loading -->
		<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
		<script>
			// Wait for Chart.js to load before loading the adapter
			if (typeof Chart !== 'undefined') {
				var script = document.createElement('script');
				script.src = 'https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js';
				document.head.appendChild(script);
			}
		</script>
		
		<!-- Tailwind CSS -->
		
		<style>
			body {
				margin: 0;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
				background-color: #f9fafb;
				color: #111827;
			}
			
			@keyframes fadeIn {
				from {
					opacity: 0;
					transform: scale(0.95);
				}
				to {
					opacity: 1;
					transform: scale(1);
				}
			}
			
			/* P5 Container Styling for light theme */
			#p5-container {
				border-radius: 12px;
				overflow: hidden;
				transition: all 0.3s ease;
				border: 2px solid #d1d5db;
				background: rgba(255, 255, 255, 0.95);
				box-shadow: 0 10px 25px rgba(0, 0, 0, 0.1);
			}
			
			/* Card Styling for light theme */
			.card {
				background-color: #ffffff;
				border: 1px solid #e5e7eb;
				box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1), 0 1px 2px rgba(0, 0, 0, 0.06);
				transition: all 0.2s ease;
			}
			.card:hover {
				box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05);
			}
			
			/* Button Styling */
			.btn {
				display: inline-flex;
				align-items: center;
				justify-content: center;
				padding: 0.5rem 1rem;
				font-size: 0.875rem;
				font-weight: 500;
				border-radius: 0.375rem;
				transition: all 0.2s ease;
				border: 1px solid transparent;
				cursor: pointer;
			}
			.btn-primary {
				background-color: #3b82f6;
				color: white;
			}
			.btn-primary:hover {
				background-color: #2563eb;
				transform: translateY(-1px);
				box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
			}
			.btn-secondary {
				background-color: #ffffff;
				color: #374151;
				border-color: #d1d5db;
			}
			.btn-secondary:hover {
				background-color: #f9fafb;
				border-color: #9ca3af;
			}
			.btn-success {
				background-color: #10b981;
				color: white;
			}
			.btn-success:hover {
				background-color: #059669;
			}
			
			/* Input Styling for light theme */
			.input {
				background-color: #f9fafb;
				border-color: #d1d5db;
				color: #111827;
			}
			.input::placeholder {
				color: #6b7280;
			}
			
			.loading-skeleton {
				animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
				background-color: #e5e7eb;
			}
			@keyframes pulse {
				0%, 100% { opacity: 1; }
				50% { opacity: .5; }
			}
			
			/* Modern Table Styling */
			.modern-table {
				width: 100%;
				border-collapse: separate;
				border-spacing: 0;
				table-layout: auto;
			}
			.modern-table thead tr {
				background-color: #f9fafb;
			}
			.modern-table th {
				padding: 0.75rem 1rem;
				text-align: left;
				font-size: 0.875rem;
				font-weight: 600;
				color: #374151;
				border-bottom: 2px solid #e5e7eb;
				white-space: nowrap;
			}
			.modern-table th:first-child {
				padding-left: 1.5rem;
			}
			.modern-table th:last-child {
				padding-right: 1.5rem;
			}
			.modern-table td {
				padding: 0.75rem 1rem;
				border-bottom: 1px solid #f3f4f6;
				font-size: 0.875rem;
				white-space: nowrap;
			}
			.modern-table td:first-child {
				padding-left: 1.5rem;
			}
			.modern-table td:last-child {
				padding-right: 1.5rem;
			}
			.modern-table tbody tr:hover {
				background-color: #f9fafb;
			}
			.modern-table tbody tr:last-child td {
				border-bottom: none;
			}
			
			/* Fluid column widths */
			.modern-table th:nth-child(1),
			.modern-table td:nth-child(1) {
				/* Timestamp - no fixed width, natural sizing */
				white-space: nowrap;
			}
			.modern-table th:last-child,
			.modern-table td:last-child {
				/* Block (with tx link) - last column */
				text-align: right;
			}
			/* Data columns - between timestamp and block */
			.modern-table th:not(:nth-child(1)):not(:last-child),
			.modern-table td:not(:nth-child(1)):not(:last-child) {
				text-align: right;
			}
			
			/* Fix header alignment */
			.modern-table th {
				vertical-align: middle;
			}
			
			/* Additional spacing for better readability */
			.modern-table th:not(:last-child),
			.modern-table td:not(:last-child) {
				padding-right: 2rem;
			}
			
			/* Responsive adjustments */
			@media (max-width: 1024px) {
				.modern-table th,
				.modern-table td {
					padding: 0.75rem 1rem;
					font-size: 0.75rem;
				}
				.modern-table th:not(:last-child),
				.modern-table td:not(:last-child) {
					padding-right: 1.5rem;
				}
			}
			
			/* Stat Card Styling */
			.stat-card {
				background: linear-gradient(135deg, #ffffff 0%, #f9fafb 100%);
				border: 1px solid #e5e7eb;
				border-radius: 0.75rem;
				padding: 1.5rem;
				transition: all 0.2s ease;
			}
			.stat-card:hover {
				transform: translateY(-2px);
				box-shadow: 0 10px 15px -3px rgba(0, 0, 0, 0.1);
			}
		</style>
	</head>
	<body class="light">
		<Header />
		<main>
			<div id="blockchain-app"></div>
		</main>
		<Footer />

		<script type="module" define:vars={{ BLOCKCHAIN_CONFIG: configJson, PAGE_DATA: pageDataJson }}>
			// Import viem modules
			import { createPublicClient, http, parseAbi, formatEther, decodeEventLog, encodeFunctionData, decodeFunctionResult } from 'https://esm.sh/viem@2.21.19';
			import { mainnet, sepolia, anvil } from 'https://esm.sh/viem@2.21.19/chains';

			// ============================================
			// Wait for blockchainUtils to be available
			// (loaded via src/scripts/blockchain-page.ts)
			// ============================================
			function waitForBlockchainUtils(maxWait = 5000) {
				return new Promise((resolve, reject) => {
					if (window.blockchainUtils) {
						resolve(window.blockchainUtils);
						return;
					}
					const startTime = Date.now();
					const checkInterval = setInterval(() => {
						if (window.blockchainUtils) {
							clearInterval(checkInterval);
							resolve(window.blockchainUtils);
						} else if (Date.now() - startTime > maxWait) {
							clearInterval(checkInterval);
							reject(new Error('Timeout waiting for blockchainUtils'));
						}
					}, 50);
				});
			}

			// Wait for utilities then initialize
			const utils = await waitForBlockchainUtils();
			const {
				getCachedEvents,
				setCachedEvents,
				getBlockFromDaysAgo,
				jibchainL1,
				sichang,
				formatScaledValue,
				formatAddress: formatAddressUtil,
				processRecordLogs,
				filterWaterLevelData,
				RECORD_STORED_EVENT,
				createFloodboyVisualization
			} = utils;

			// Make viem and chains available globally
			window.viem = { createPublicClient, http, parseAbi, formatEther, decodeEventLog, encodeFunctionData, decodeFunctionResult };
			window.chains = { mainnet, sepolia, anvil, jibchainL1, sichang };

			// Parse page data from server
			const pageData = JSON.parse(PAGE_DATA);
			
			// Use resolved address from server or fall back to URL parsing
			const storeAddress = pageData.address || (() => {
				const urlParts = window.location.pathname.split('/');
				return urlParts[urlParts.length - 1];
			})();

			// Contract ABIs and configurations
			// Configuration injected at build time
			const CONTRACTS = JSON.parse(BLOCKCHAIN_CONFIG);
			
			// Use the ABI loaded from abis.js
			const STORE_ABI = pageData.storeABI;

			// Note: RECORD_STORED_EVENT, formatScaledValue, processRecordLogs, filterWaterLevelData
			// are now imported from window.blockchainUtils above

			// FloodboyVisualization - use factory from extracted module
			const FloodboyVisualization = createFloodboyVisualization(React);

			// Main BlockchainApp Component
                        function BlockchainApp() {
                                function getChainConfigForId(chainId) {
                                        switch (chainId) {
                                                case 8899:
                                                        return window.chains.jibchainL1;
                                                case 700011:
                                                        return window.chains.sichang;
                                                case 31337:
                                                        return window.chains.anvil;
                                                default:
                                                        return window.chains.jibchainL1;
                                        }
                                }

                                function getRpcUrlsForChain(chainId) {
                                        const chainConfig = getChainConfigForId(chainId);
                                        if (!chainConfig) return [];

                                        const defaultUrls = chainConfig?.rpcUrls?.default?.http || [];
                                        const publicUrls = chainConfig?.rpcUrls?.public?.http || [];
                                        const combined = [...defaultUrls];

                                        for (const url of publicUrls) {
                                                if (!combined.includes(url)) {
                                                        combined.push(url);
                                                }
                                        }

                                        return combined;
                                }

                                function getRpcUrlForChain(chainId) {
                                        const urls = getRpcUrlsForChain(chainId);
                                        return urls.length > 0 ? urls[0] : null;
                                }

                                async function getClientWithFallback(chainId, { onRpcSelected, performHealthCheck = true } = {}) {
                                        const chainConfig = getChainConfigForId(chainId);
                                        const rpcUrls = getRpcUrlsForChain(chainId);

                                        if (!chainConfig || rpcUrls.length === 0) {
                                                throw new Error('No RPC endpoints configured for this chain.');
                                        }

                                        let lastError = null;

                                        for (const url of rpcUrls) {
                                                try {
                                                        const client = window.viem.createPublicClient({
                                                                chain: chainConfig,
                                                                transport: window.viem.http(url)
                                                        });

                                                        let blockNumber = null;

                                                        if (performHealthCheck) {
                                                                blockNumber = await client.getBlockNumber();
                                                        }

                                                        if (typeof onRpcSelected === 'function') {
                                                                onRpcSelected(url, blockNumber);
                                                        }

                                                        return { client, rpcUrl: url, blockNumber };
                                                } catch (err) {
                                                        lastError = err;
                                                        console.warn(`RPC endpoint failed for chain ${chainId}: ${url}`, err);
                                                }
                                        }

                                        const error = lastError || new Error('Unable to connect to any RPC endpoints.');
                                        throw error;
                                }

                                const [currentChain, setCurrentChain] = React.useState(8899);
                                const [storeData, setStoreData] = React.useState(null);
                                const [isLoading, setIsLoading] = React.useState(true);
                                const [isRefreshing, setIsRefreshing] = React.useState(false);
                                const [activeRpcUrl, setActiveRpcUrl] = React.useState(() => getRpcUrlForChain(8899));

				// Use extracted utilities (defined at top-level from window.blockchainUtils)
				const formatAddress = formatAddressUtil;
				const getExplorerUrl = window.blockchainUtils.getExplorerUrl;

				const [waterLevel, setWaterLevel] = React.useState(0);
				const [temperature, setTemperature] = React.useState(0);
				const [installationHeight, setInstallationHeight] = React.useState(3.0); // Default 3m, will be updated from contract
				const [isOnline, setIsOnline] = React.useState(true);
				const [error, setError] = React.useState(null);
				const [lastUpdated, setLastUpdated] = React.useState(null);
				const [sensorRecords, setSensorRecords] = React.useState([]);
				const [authorizedSensors, setAuthorizedSensors] = React.useState([]);
				const [recentEvents, setRecentEvents] = React.useState([]);
				const [activeTab, setActiveTab] = React.useState('chart'); // 'table' or 'chart' - default to chart
				const chartRef = React.useRef(null);
				const chartInstanceRef = React.useRef(null);
				
				// Block indicator states
				const [blockNumber, setBlockNumber] = React.useState(null);
				const [blockTimer, setBlockTimer] = React.useState(0);
				const [showBlockIndicator, setShowBlockIndicator] = React.useState(true);
				const blockTimerRef = React.useRef(null);
				
				// Enhanced view states
                                const [isMaximized, setIsMaximized] = React.useState(false);
                                const [showAllRecords, setShowAllRecords] = React.useState(false);
                                const [recordsLimit, setRecordsLimit] = React.useState(10); // Default to 10 records
                                const [selectedFields, setSelectedFields] = React.useState(['water_depth']); // Default to water depth only
                                const [startFromZero, setStartFromZero] = React.useState(true); // Default to start from zero
                                const [groupingInterval, setGroupingInterval] = React.useState('3hr'); // Default to 3 hour grouping

                                // Lazy loading state - default to 7 days for fast initial load
                                const [loadRange, setLoadRange] = React.useState(7); // days - 7 = last week, 30 = last month, 0 = all
                                const [isLoadingMore, setIsLoadingMore] = React.useState(false);
                                const [hasMoreData, setHasMoreData] = React.useState(true); // Whether there's older data available

                                // Fetch logs in manageable chunks to avoid RPC limitations
                                async function fetchLogsInChunks({ client, address, event, fromBlock, toBlock, initialBatchSize = 50000n, maxRetries = 3 }) {
                                        const logs = [];
                                        const startBlock = BigInt(fromBlock);
                                        let latestBlock;

                                        if (typeof toBlock === 'string') {
                                                if (toBlock.toLowerCase() === 'latest') {
                                                        latestBlock = await client.getBlockNumber();
                                                } else {
                                                        latestBlock = BigInt(toBlock);
                                                }
                                        } else {
                                                latestBlock = BigInt(toBlock);
                                        }
                                        let batchSize = initialBatchSize;
                                        let currentFrom = startBlock;

                                        while (currentFrom <= latestBlock) {
                                                let currentTo = currentFrom + batchSize;
                                                if (currentTo > latestBlock) {
                                                        currentTo = latestBlock;
                                                }

                                                let attempt = 0;
                                                while (attempt < maxRetries) {
                                                        try {
                                                                const chunkLogs = await client.getLogs({
                                                                        address,
                                                                        event,
                                                                        fromBlock: currentFrom,
                                                                        toBlock: currentTo
                                                                });
                                                                logs.push(...chunkLogs);
                                                                break;
                                                        } catch (chunkError) {
                                                                attempt += 1;
                                                                console.warn(`getLogs failed for range ${currentFrom.toString()} - ${currentTo.toString()} (attempt ${attempt}/${maxRetries}):`, chunkError);

                                                                if (attempt >= maxRetries) {
                                                                        throw chunkError;
                                                                }

                                                                batchSize = batchSize / 2n;
                                                                if (batchSize < 1000n) {
                                                                        batchSize = 1000n;
                                                                }

                                                                currentTo = currentFrom + batchSize;
                                                                if (currentTo > latestBlock) {
                                                                        currentTo = latestBlock;
                                                                }
                                                        }
                                                }

                                                currentFrom = currentTo + 1n;
                                        }

                                        return logs;
                                }

				// Aggregate data by time intervals
				const aggregateDataByInterval = React.useCallback((records, interval) => {
					if (!records || records.length === 0 || interval === 'none') return records;
					
					// Helper to round timestamp down to nearest interval boundary
					const roundToInterval = (timestamp) => {
						const date = new Date(timestamp * 1000);
						date.setSeconds(0);
						date.setMilliseconds(0);
						
						switch (interval) {
							case '15min':
								const minutes15 = Math.floor(date.getMinutes() / 15) * 15;
								date.setMinutes(minutes15);
								break;
							case '30min':
								const minutes30 = Math.floor(date.getMinutes() / 30) * 30;
								date.setMinutes(minutes30);
								break;
							case '1hr':
								date.setMinutes(0);
								break;
							case '3hr':
								date.setMinutes(0);
								const hours3 = Math.floor(date.getHours() / 3) * 3;
								date.setHours(hours3);
								break;
							case '6hr':
								date.setMinutes(0);
								const hours6 = Math.floor(date.getHours() / 6) * 6;
								date.setHours(hours6);
								break;
							default:
								return timestamp;
						}
						
						return Math.floor(date.getTime() / 1000);
					};
					
					// Group records by time windows
					const groups = {};
					records.forEach(record => {
						const windowStart = roundToInterval(record.timestamp);
						if (!groups[windowStart]) {
							groups[windowStart] = [];
						}
						groups[windowStart].push(record);
					});
					
					// Aggregate each group
					const aggregatedRecords = Object.entries(groups).map(([windowStart, windowRecords]) => {
						const timestamp = parseInt(windowStart);
						
						// For each field, apply appropriate aggregation
						const aggregatedValues = storeData.fields.map((field, fieldIndex) => {
							const values = windowRecords
								.map(r => r.values[fieldIndex])
								.filter(v => v !== null && v !== undefined);
							
							if (values.length === 0) return null;
							
							// Apply field-specific aggregation strategy
							if (field.name.endsWith('_min')) {
								// For min fields, take the minimum
								return Math.min(...values);
							} else if (field.name.endsWith('_max')) {
								// For max fields, take the maximum
								return Math.max(...values);
							} else if (field.name.endsWith('_count')) {
								// For count fields, sum them
								return values.reduce((sum, val) => sum + val, 0);
							} else if (field.name === 'installation_height') {
								// Installation height is typically constant, take the first value
								return values[0];
							} else {
								// For regular fields (water_depth, battery_voltage, etc.), take average
								const sum = values.reduce((acc, val) => acc + val, 0);
								return sum / values.length;
							}
						});
						
						// Use the first record's metadata as representative
						const representativeRecord = windowRecords[0];
						
						return {
							sensor: representativeRecord.sensor,
							timestamp: timestamp,
							values: aggregatedValues,
							blockNumber: windowRecords[windowRecords.length - 1].blockNumber, // Last block in window
							transactionHash: representativeRecord.transactionHash,
							// Add metadata about aggregation
							aggregated: true,
							recordCount: windowRecords.length,
							originalTimestamps: windowRecords.map(r => r.timestamp)
						};
					});
					
					// Sort by timestamp ascending (for chart display)
					return aggregatedRecords.sort((a, b) => a.timestamp - b.timestamp);
				}, [storeData]);

				// Create chart function
				const createChart = React.useCallback(() => {
					if (!chartRef.current || !sensorRecords.length || !storeData?.fields) return;

					// Always destroy and recreate when selectedFields changes
					// This ensures the chart shows the correct fields
					if (chartInstanceRef.current) {
						chartInstanceRef.current.destroy();
						chartInstanceRef.current = null;
					}

					const ctx = chartRef.current.getContext('2d');
					
					// Prepare data for chart
					const sortedRecords = [...sensorRecords].sort((a, b) => a.timestamp - b.timestamp);
					
					// Apply time interval grouping if enabled
                                        const processedRecords = groupingInterval !== 'none' ?
                                                aggregateDataByInterval(sortedRecords, groupingInterval) :
                                                sortedRecords;

                                        // Filter chart data to only include records from September 9, 2025 onward
                                        const chartCutoffTimestamp = Math.floor(new Date('2025-09-09T00:00:00Z').getTime() / 1000);
                                        const chartRecords = processedRecords.filter(record => record.timestamp >= chartCutoffTimestamp);

                                        // Format labels based on grouping mode
                                        const labels = chartRecords.map(record => {
						const date = new Date(record.timestamp * 1000);
						if (groupingInterval !== 'none') {
							// For grouped data, show cleaner time format
							return date.toLocaleString('en-US', {
								month: 'short',
								day: 'numeric',
								hour: '2-digit',
								minute: '2-digit',
								hour12: false
							});
						}
						return date.toLocaleString();
					});

					// Create datasets - show only selected fields
                                        const hexToRgba = (hex, alpha = 1) => {
                                                const sanitized = hex.replace('#', '');
                                                const bigint = parseInt(sanitized.length === 3
                                                        ? sanitized.split('').map(char => char + char).join('')
                                                        : sanitized, 16);
                                                const r = (bigint >> 16) & 255;
                                                const g = (bigint >> 8) & 255;
                                                const b = bigint & 255;
                                                return `rgba(${r}, ${g}, ${b}, ${alpha})`;
                                        };

                                        const waterDepthColor = '#0ea5e9';

                                        const fallbackPalette = [
                                                waterDepthColor, // sky-500
                                                '#2563eb', // blue-600
                                                '#7c3aed', // violet-600
                                                '#16a34a', // green-600
                                                '#f97316', // orange-500
                                                '#ef4444', // red-500
                                                '#14b8a6', // teal-500
                                                '#f59e0b'  // amber-500
                                        ];

                                        const datasets = storeData.fields
						.filter((field, fieldIndex) => {
							// Show only selected fields (not _min, _max, _count variants)
							return selectedFields.includes(field.name) && 
								   !field.name.endsWith('_min') && 
								   !field.name.endsWith('_max') && 
								   !field.name.endsWith('_count');
						})
						.map((field, index) => {
							const fieldIndex = storeData.fields.findIndex(f => f.name === field.name);
                                                        const colors = {
                                                                'water_depth': waterDepthColor, // Sky
                                                                'installation_height': '#16a34a', // Green
                                                                'battery_voltage': '#a855f7', // Purple
                                                        };
                                                        const color = colors[field.name] || fallbackPalette[index % fallbackPalette.length];
							
                                                        const data = chartRecords.map(record => {
								if (record.values[fieldIndex] !== undefined) {
									return parseFloat(formatScaledValue(record.values[fieldIndex], field.unit));
								}
								return null;
							});

							// Format field name for display
							const fieldLabel = field.name.split('_').map(word => 
								word.charAt(0).toUpperCase() + word.slice(1)
							).join(' ');

							return {
								label: `${fieldLabel} (${field.unit.replace(/ x\d+$/, '')})`,
								data: data,
								borderColor: color,
                                                                backgroundColor: hexToRgba(color, 0.15),
                                                                borderWidth: 3,
								tension: 0.4,
								fill: field.name === 'water_depth', // Only fill water depth
								spanGaps: true,
								pointRadius: 2,
								pointHoverRadius: 4,
                                                                pointBackgroundColor: color,
                                                                pointBorderColor: color,
                                                                pointBorderWidth: 1
                                                        };
                                                });

					// Check if this is an update or initial creation
					const isUpdate = chartInstanceRef.current !== null;
					
					chartInstanceRef.current = new Chart(ctx, {
						type: 'line',
						data: {
							labels: labels,
							datasets: datasets
						},
						options: {
							responsive: true,
							maintainAspectRatio: false,
							animation: {
								duration: isUpdate ? 0 : 750 // No animation on updates
							},
							plugins: {
								title: {
									display: true,
									text: (selectedFields.length === 1 && selectedFields[0] === 'water_depth' 
										? 'Water Depth Over Time' 
										: 'Sensor Data Over Time') + (groupingInterval !== 'none' ? ` (${groupingInterval} avg)` : ''),
									font: {
										size: 16,
										weight: '600'
									}
								},
								legend: {
									display: true,
									position: 'top'
								},
								tooltip: {
									callbacks: {
										afterLabel: function(context) {
											// Show aggregation info in tooltip when grouping is enabled
                                                                                        if (groupingInterval !== 'none' && chartRecords[context.dataIndex]) {
                                                                                                const record = chartRecords[context.dataIndex];
												if (record.aggregated && record.recordCount) {
													return `Aggregated from ${record.recordCount} records`;
												}
											}
											return '';
										}
									}
								}
							},
							scales: {
								x: {
									display: true,
									title: {
										display: true,
										text: 'Time'
									},
									ticks: {
										maxTicksLimit: 10
									}
								},
								y: {
									display: true,
									title: {
										display: true,
										text: selectedFields.length === 1 
											? datasets.length > 0 ? datasets[0].label : 'Value'
											: 'Value'
									},
									beginAtZero: startFromZero,
									...(startFromZero ? {} : {
										// For relative scale, add some padding
										grace: '5%'
									})
								}
							},
							interaction: {
								mode: 'index',
								intersect: false,
							}
						}
					});
				}, [sensorRecords, storeData, selectedFields, startFromZero, groupingInterval, aggregateDataByInterval]);

				// Update chart when data changes
				React.useEffect(() => {
					if (activeTab === 'chart' && sensorRecords.length > 0 && selectedFields.length > 0) {
						// Small delay to ensure canvas is ready
						setTimeout(() => {
							createChart();
						}, 100);
					}
					
					// Cleanup on unmount
					return () => {
						if (chartInstanceRef.current) {
							chartInstanceRef.current.destroy();
							chartInstanceRef.current = null;
						}
					};
				}, [activeTab, sensorRecords, selectedFields, createChart, startFromZero, groupingInterval]);

				// Define loadEnhancedStoreData function
				const loadEnhancedStoreData = React.useCallback(async () => {
						// Only set loading on initial load, use refreshing for updates
						if (!storeData) {
							setIsLoading(true);
						} else {
							setIsRefreshing(true);
						}
						setError(null);
						
                                                try {
                                                        const { client: publicClient, rpcUrl, blockNumber: initialBlockNumber } = await getClientWithFallback(
                                                                currentChain,
                                                                {
                                                                        onRpcSelected: (url) => setActiveRpcUrl(url)
                                                                }
                                                        );

                                                        const currentBlockNumber =
                                                                typeof initialBlockNumber === 'bigint'
                                                                        ? initialBlockNumber
                                                                        : await publicClient.getBlockNumber();
                                                        setBlockNumber(currentBlockNumber);

							// Use multicall3 for parallel loading
							const MULTICALL3_ADDRESS = '0xcA11bde05977b3631167028862bE2a173976CA11';
							const MULTICALL3_ABI = [
								{
									inputs: [
										{
											components: [
												{ name: 'target', type: 'address' },
												{ name: 'allowFailure', type: 'bool' },
												{ name: 'callData', type: 'bytes' }
											],
											name: 'calls',
											type: 'tuple[]'
										}
									],
									name: 'aggregate3',
									outputs: [
										{
											components: [
												{ name: 'success', type: 'bool' },
												{ name: 'returnData', type: 'bytes' }
											],
											name: 'returnData',
											type: 'tuple[]'
										}
									],
									stateMutability: 'payable',
									type: 'function'
								}
							];
							
							// Import encodeFunctionData from viem
							const { encodeFunctionData, decodeFunctionResult } = window.viem;
							
							// Get factory address for current chain
							const factoryAddress = currentChain === 8899 ? '0x63bB41b79b5aAc6e98C7b35Dcb0fE941b85Ba5Bb' : CONTRACTS[currentChain]?.deployerAddress;
							const DEPLOYER_ABI = pageData.deployerABI;
							
							// Prepare multicall
							const calls = [
								{
									target: storeAddress,
									allowFailure: true,
									callData: encodeFunctionData({
										abi: STORE_ABI,
										functionName: 'owner'
									})
								},
								{
									target: storeAddress,
									allowFailure: true,
									callData: encodeFunctionData({
										abi: STORE_ABI,
										functionName: 'getAllFields'
									})
								},
								{
									target: storeAddress,
									allowFailure: true,
									callData: encodeFunctionData({
										abi: STORE_ABI,
										functionName: 'authorizedSignerCount'
									})
								}
							];
							
							// Factory calls are now made directly after multicall
							
							// Execute multicall
							const results = await publicClient.readContract({
								address: MULTICALL3_ADDRESS,
								abi: MULTICALL3_ABI,
								functionName: 'aggregate3',
								args: [calls]
							});
							
							// Decode results
							const owner = results[0].success ? decodeFunctionResult({
								abi: STORE_ABI,
								functionName: 'owner',
								data: results[0].returnData
							}) : null;
							
							const fields = results[1].success ? decodeFunctionResult({
								abi: STORE_ABI,
								functionName: 'getAllFields',
								data: results[1].returnData
							}) : [];
							
							const authorizedSignerCount = results[2].success ? decodeFunctionResult({
								abi: STORE_ABI,
								functionName: 'authorizedSignerCount',
								data: results[2].returnData
							}) : 0;
							
							// Make direct factory calls (only for JIBCHAIN L1 where we know the factory works)
							let nickname = null;
							let description = null;
							let deployedBlockInfo = null;
							let metadata = null;
							
							// Only try factory calls on JIBCHAIN L1 with known factory
							if (factoryAddress && currentChain === 8899 && factoryAddress === '0x63bB41b79b5aAc6e98C7b35Dcb0fE941b85Ba5Bb') {
								// Try storeToNickname first (simplest call)
								try {
									nickname = await publicClient.readContract({
										address: factoryAddress,
										abi: DEPLOYER_ABI,
										functionName: 'storeToNickname',
										args: [storeAddress]
									});
								} catch (nicknameErr) {
									// storeToNickname failed
								}

								// Try getStoreMetadata
								try {
									metadata = await publicClient.readContract({
										address: factoryAddress,
										abi: DEPLOYER_ABI,
										functionName: 'getStoreMetadata',
										args: [storeAddress]
									});
									if (metadata && metadata.length >= 3) {
										// getStoreMetadata returns: [deployedBlock, lastUpdatedBlock, description, pointer]
										deployedBlockInfo = metadata[0];
										description = metadata[2]; // description is at index 2
									}
								} catch (metadataErr) {
									// getStoreMetadata failed
								}

								// Try getStoreInfo as fallback
								try {
									const storeInfo = await publicClient.readContract({
										address: factoryAddress,
										abi: DEPLOYER_ABI,
										functionName: 'getStoreInfo',
										args: [storeAddress]
									});
									if (storeInfo && storeInfo.length >= 5) {
										// getStoreInfo returns: [nickname, owner, authorizedSensorCount, deployedBlock, description]
										if (!nickname) nickname = storeInfo[0];
										if (!deployedBlockInfo) deployedBlockInfo = storeInfo[3];
										if (!description) description = storeInfo[4]; // description is at index 4
									}
								} catch (storeInfoErr) {
									// getStoreInfo failed
								}
							}
							

							// ============================================
							// OPTIMIZED: Lazy loading + IndexedDB caching
							// ============================================
                                                        const latestBlock = currentBlockNumber;
                                                        const deploymentBlock = currentChain === 8899 ? BigInt(5900000) : BigInt(0);

							// Get total records from factory contract
							let totalRecords = 0;
							try {
								totalRecords = await publicClient.readContract({
									address: factoryAddress,
									abi: [
										{
											"inputs": [{"name": "_store", "type": "address"}],
											"name": "getTotalRecords",
											"outputs": [{"name": "", "type": "uint256"}],
											"stateMutability": "view",
											"type": "function"
										}
									],
									functionName: 'getTotalRecords',
									args: [storeAddress]
								});
								totalRecords = Number(totalRecords);
							} catch (error) {
								// Factory contract not available, will use event count fallback
							}

							// Try to load from IndexedDB cache first
							let cachedData = null;
							let cachedEvents = [];
							let cacheLastBlock = 0n;

							try {
								cachedData = await getCachedEvents(storeAddress, currentChain);
								if (cachedData && cachedData.events && cachedData.lastBlock) {
									cachedEvents = cachedData.events;
									cacheLastBlock = BigInt(cachedData.lastBlock);
								}
							} catch (cacheErr) {
								// Cache read failed, proceed without cache
							}

							// Determine fromBlock based on lazy loading setting
							let fromBlock;
							if (loadRange === 0) {
								// Load all data
								fromBlock = cacheLastBlock > deploymentBlock ? cacheLastBlock + 1n : deploymentBlock;
							} else {
								// Lazy load: only fetch last N days
								const lazyFromBlock = getBlockFromDaysAgo(latestBlock, loadRange, currentChain);
								fromBlock = lazyFromBlock > deploymentBlock ? lazyFromBlock : deploymentBlock;

								// If cache covers our range, use cache's last block
								if (cacheLastBlock > fromBlock) {
									fromBlock = cacheLastBlock + 1n;
								}
							}

							// Check if there's more historical data available
							setHasMoreData(loadRange > 0 && fromBlock > deploymentBlock);

							// Fetch only new events (incremental)
							let newEventLogs = [];
							if (fromBlock <= latestBlock) {
								newEventLogs = await fetchLogsInChunks({
									client: publicClient,
									address: storeAddress,
									event: RECORD_STORED_EVENT,
									fromBlock,
									toBlock: latestBlock,
									initialBatchSize: currentChain === 8899 ? 50000n : 20000n
								}).catch(() => []);
							}

							// Merge cached + new events
							const eventLogs = [...cachedEvents, ...newEventLogs];

							// Update cache with all events (if we got new ones)
							if (newEventLogs.length > 0) {
								// Serialize events for IndexedDB (convert BigInt to string)
								const serializableEvents = eventLogs.map(log => ({
									...log,
									blockNumber: log.blockNumber?.toString(),
									args: log.args ? {
										sensor: log.args.sensor,
										timestamp: log.args.timestamp?.toString(),
										values: log.args.values?.map(v => v?.toString())
									} : null
								}));
								setCachedEvents(storeAddress, currentChain, serializableEvents, latestBlock).catch(() => {});
							}

							// Process events
							const processedRecords = processRecordLogs(eventLogs);

							// Apply smart water level filtering (FloodBoy020 only)
							const filteredRecords = filterWaterLevelData(processedRecords, fields, storeAddress);

							const allRecords = filteredRecords;

							// Get latest record data
							let latestRecord = null;
							let processedData = {};

							if (processedRecords.length > 0) {
								latestRecord = processedRecords[0]; // Most recent
								
								// Process latest values with proper scaling
								fields.forEach((field, index) => {
									if (latestRecord.values[index] !== undefined) {
										const scaledValue = formatScaledValue(latestRecord.values[index], field.unit);
										processedData[field.name] = parseFloat(scaledValue);
									}
								});
							} else {
								// Fallback to direct contract call
								try {
									const [timestamp, values] = await publicClient.readContract({
										address: storeAddress,
										abi: STORE_ABI,
										functionName: 'getLatestRecord',
										args: [owner]
									});

									if (Number(timestamp) > 0) {
										fields.forEach((field, index) => {
											if (values[index] !== undefined) {
												const scaledValue = formatScaledValue(values[index], field.unit);
												processedData[field.name] = parseFloat(scaledValue);
											}
										});
										latestRecord = {
											sensor: owner,
											timestamp: Number(timestamp),
											values: values.map(v => Number(v))
										};
									}
								} catch (directCallErr) {
									// Direct call also failed
								}
							}

							// Update state with enhanced data
							setStoreData({
								address: storeAddress,
								name: nickname || description || "Sensor Store", // Use nickname first, then description
								nickname: nickname,
								description: description || metadata?.description, // Use description from getStoreInfo first
								pointer: metadata?.pointer,
								deployedBlock: deployedBlockInfo || metadata?.deployedBlock,
								lastUpdatedBlock: metadata?.lastUpdatedBlock,
								owner: owner,
								fields: fields,
								lastTimestamp: latestRecord?.timestamp || 0,
								totalRecords: totalRecords || processedRecords.length
							});

							
							// Only update sensor records if they actually changed
							setSensorRecords(prevRecords => {
								// Check if records are different
								if (prevRecords.length !== allRecords.length) {
									return allRecords;
								}
								
								// Deep comparison without JSON.stringify to handle BigInt
								const hasChanged = prevRecords.some((record, index) => {
									const newRecord = allRecords[index];
									return record.timestamp !== newRecord.timestamp ||
										   record.sensor !== newRecord.sensor ||
										   record.transactionHash !== newRecord.transactionHash ||
										   record.blockNumber !== newRecord.blockNumber ||
										   record.values.some((val, i) => val !== newRecord.values[i]);
								});
								
								if (hasChanged) {
									return allRecords;
								}
								return prevRecords; // Keep the same reference to avoid re-render
							});
							setRecentEvents(eventLogs.slice(0, 5)); // Last 5 events

							// Set sensor values with fallback
							if (processedData.water_depth !== undefined) {
								setWaterLevel(processedData.water_depth);
							} else if (processedData.water_level !== undefined) {
								setWaterLevel(processedData.water_level);
							} else if (processedData.level !== undefined) {
								setWaterLevel(processedData.level);
							}
							
							if (processedData.temperature !== undefined) {
								setTemperature(processedData.temperature);
							} else if (processedData.temp !== undefined) {
								setTemperature(processedData.temp);
							}
							
							// Set installation height if available
							if (processedData.installation_height !== undefined) {
								setInstallationHeight(processedData.installation_height);
							}

							if (latestRecord) {
								setLastUpdated(new Date(latestRecord.timestamp * 1000));
								setIsOnline(true);
							} else {
								setIsOnline(false);
							}

						} catch (err) {
                                                        console.error('Error loading enhanced store data:', err);
                                                        setError(err.message || 'Unable to load store data from available RPC endpoints.');
							// Set fallback data
							setStoreData({
								address: storeAddress,
								name: "Sensor Store (Offline)",
								nickname: null,
								description: null,
								pointer: null,
								deployedBlock: null,
								lastUpdatedBlock: null,
								owner: "Unable to load",
								fields: [],
								lastTimestamp: 0
							});
							setIsOnline(false);
						}
						
						setIsLoading(false);
						setIsRefreshing(false);
				}, [storeAddress, loadRange]);
				
				// Load on mount and when loadRange changes
				React.useEffect(() => {
					loadEnhancedStoreData().finally(() => {
						setIsLoadingMore(false);
					});
				}, [loadRange]);

				// Cleanup chart on unmount
				React.useEffect(() => {
					return () => {
						if (chartInstanceRef.current) {
							chartInstanceRef.current.destroy();
						}
					};
				}, []);

				// Simple block watcher using viem watchBlocks
                                React.useEffect(() => {
                                        let unwatch;
                                        let isMounted = true;

                                        async function setupWatcher() {
                                                if (currentChain !== 8899) {
                                                        return;
                                                }

                                                try {
                                                        const { client: publicClient } = await getClientWithFallback(currentChain, {
                                                                onRpcSelected: (url) => {
                                                                        if (isMounted) {
                                                                                setActiveRpcUrl(url);
                                                                        }
                                                                },
                                                                performHealthCheck: false
                                                        });

                                                        if (!isMounted) {
                                                                return;
                                                        }

                                                        // Use viem's watchBlocks for efficient block monitoring
                                                        unwatch = publicClient.watchBlocks({
                                                                onBlock: async (block) => {
                                                                        setBlockNumber(block.number);

                                                                        // Don't auto-refresh data - let user control when to refresh
                                                                        // This prevents chart from re-rendering constantly
                                                                },
                                                                pollingInterval: 3000, // 3 seconds
                                                        });
                                                } catch (watchError) {
                                                        console.error('Failed to initialize block watcher:', watchError);
                                                }
                                        }

                                        setupWatcher();

                                        return () => {
                                                isMounted = false;
                                                if (unwatch) {
                                                        unwatch();
                                                }
                                        };
                                }, [currentChain]);

				// Handle block timer and visibility for JBC chain
				React.useEffect(() => {
					if (blockNumber !== null && currentChain === 8899) {
						// Reset timer and show indicator when block changes
						setBlockTimer(1);
						setShowBlockIndicator(true);
						
						// Clear existing timer
						if (blockTimerRef.current) {
							clearInterval(blockTimerRef.current);
						}
						
						// Start new timer
						blockTimerRef.current = setInterval(() => {
							setBlockTimer(prev => {
								const newTimer = prev + 1;
								// Hide indicator after 15 seconds
								if (newTimer >= 15) {
									setShowBlockIndicator(false);
									if (blockTimerRef.current) {
										clearInterval(blockTimerRef.current);
									}
								}
								return newTimer;
							});
						}, 1000);
					}
					
					return () => {
						if (blockTimerRef.current) {
							clearInterval(blockTimerRef.current);
						}
					};
				}, [blockNumber, currentChain]);
				
				// Keyboard shortcuts
				React.useEffect(() => {
					const handleKeyPress = (e) => {
						// ESC to exit maximize
						if (e.key === 'Escape' && isMaximized) {
							setIsMaximized(false);
						}
						// F to toggle fullscreen (with modifier key)
						if ((e.key === 'f' || e.key === 'F') && (e.ctrlKey || e.metaKey)) {
							e.preventDefault();
							if (!isMaximized) {
								// When maximizing, default to 100 records
								setRecordsLimit(100);
							}
							setIsMaximized(!isMaximized);
						}
					};
					
					if (typeof window !== 'undefined') {
						window.addEventListener('keydown', handleKeyPress);
						return () => window.removeEventListener('keydown', handleKeyPress);
					}
				}, [isMaximized]);

				// Check for alias resolution error first
				if (pageData.error) {
					return React.createElement('div', { className: 'container mx-auto p-4 sm:p-6' },
						React.createElement('div', { className: 'text-center' },
							React.createElement('div', { className: 'bg-red-50 border border-red-200 rounded-lg p-6 max-w-md mx-auto' },
								React.createElement('h3', { className: 'text-lg font-semibold text-red-800 mb-2' }, 'Invalid Store Alias'),
								React.createElement('p', { className: 'text-red-600 mb-4' }, pageData.error),
								React.createElement('p', { className: 'text-gray-600 text-sm mb-4' }, 
									'The alias you entered does not exist. Please check the URL and try again.'
								),
								React.createElement('a', { 
									href: '/blockchain',
									className: 'inline-flex items-center px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 transition-colors'
								}, 'View All Stores'),
								React.createElement('div', { className: 'mt-4' },
									React.createElement('a', { 
										href: '/s/',
										className: 'text-sm text-blue-600 hover:text-blue-800'
									}, 'View Store Directory')
								)
							)
						)
					);
				}

				// Only show loading spinner on initial load when no data exists
				if (isLoading && !storeData) {
					return React.createElement('div', { className: 'container mx-auto p-4 sm:p-6' },
                                                React.createElement('div', { className: 'text-center' },
                                                        React.createElement('div', { className: 'animate-spin rounded-full h-12 w-12 border-b-2 border-blue-600 mx-auto mb-4' }),
                                                        React.createElement('p', { className: 'text-gray-600' }, 'Loading blockchain data...'),
                                                        React.createElement('p', { className: 'text-gray-500 text-xs mt-2 font-mono' }, activeRpcUrl ? `RPC: ${activeRpcUrl}` : 'RPC: selecting optimal endpoint...'),
                                                        React.createElement('p', { className: 'text-gray-500 text-sm mt-2 font-mono' }, storeAddress)
                                                )
					);
				}

				if (error) {
					return React.createElement('div', { className: 'container mx-auto p-4 sm:p-6' },
						React.createElement('div', { className: 'text-center' },
							React.createElement('div', { className: 'bg-red-50 border border-red-200 rounded-lg p-6 max-w-md mx-auto' },
								React.createElement('h3', { className: 'text-lg font-semibold text-red-800 mb-2' }, 'Connection Error'),
								React.createElement('p', { className: 'text-red-600 mb-4' }, error),
								React.createElement('p', { className: 'text-gray-600 text-sm font-mono' }, storeAddress),
								React.createElement('button', { 
									className: 'mt-4 btn btn-primary',
									onClick: () => window.location.reload()
								}, 'Retry')
							)
						)
					);
				}

				return React.createElement('div', { className: 'container mx-auto p-4 sm:p-6 relative' },
					// Refresh indicator
					isRefreshing && React.createElement('div', { 
						className: 'absolute top-4 right-4 z-10 flex items-center gap-2 bg-gray-800/80 backdrop-blur-sm rounded-lg px-3 py-1.5'
					},
						React.createElement('div', { 
							className: 'animate-spin rounded-full h-4 w-4 border-2 border-gray-600 border-t-purple-400'
						}),
						React.createElement('span', { className: 'text-sm text-gray-400' }, 'Updating...')
					),
					// Back to stores button
					React.createElement('div', { className: 'mb-6' },
						React.createElement('a', { 
							href: '/blockchain',
							className: 'inline-flex items-center text-sm text-gray-600 hover:text-gray-900 transition-colors'
						},
							React.createElement('svg', { 
								className: 'mr-2',
								width: '16',
								height: '16',
								viewBox: '0 0 24 24',
								fill: 'none',
								stroke: 'currentColor',
								strokeWidth: '2'
							},
								React.createElement('path', { d: 'm15 18-6-6 6-6' })
							),
							'Back to all stores'
						)
					),

					// Store Data Section with header inside
					React.createElement('div', { className: 'card border rounded-lg p-6 mb-8' },
						React.createElement('div', { className: 'space-y-4' },
							// Header section inside the box
							React.createElement('div', { className: 'flex items-center justify-between pb-4 border-b' },
								React.createElement('div', {},
									React.createElement('h1', { className: 'text-2xl font-bold text-gray-900 mb-1' }, 
										storeData?.nickname || pageData.aliasInfo?.displayName || 'Public Sensor Store View'
									),
									React.createElement('p', { className: 'text-gray-600 text-sm' }, 
										pageData.aliasInfo ? 'View sensor data stored on the blockchain' : 'View sensor data stored on the blockchain'
									),
									pageData.aliasInfo && React.createElement('p', { className: 'text-xs text-gray-500 mt-1' }, 
										`Alias: /${pageData.aliasInfo.alias}`
									),
									React.createElement('a', { 
										href: `${getExplorerUrl(currentChain)}/address/${storeAddress}`,
										target: '_blank',
										rel: 'noopener noreferrer',
										className: 'text-blue-600 hover:text-blue-700 font-mono text-xs mt-1 block hover:underline'
									}, storeAddress),
								),
								React.createElement('div', { className: 'space-y-2' },
									React.createElement('div', { className: 'flex gap-2' },
										React.createElement('button', { 
											className: 'btn btn-primary text-sm px-3 py-1',
											onClick: () => window.location.reload()
										}, ' Refresh'),
										React.createElement('a', { 
											href: `${getExplorerUrl(currentChain)}/address/${storeAddress}`,
											target: '_blank',
											className: 'btn btn-secondary text-sm px-3 py-1'
										}, ' Explorer')
									),
									React.createElement('div', { className: 'text-xs text-gray-600 space-y-0.5' },
										React.createElement('div', {},
											React.createElement('span', { className: 'font-medium' }, 'Current Block: '),
											React.createElement('span', { className: 'font-mono' }, 
												blockNumber ? Number(blockNumber).toLocaleString() : 'Loading...'
											)
										),
									)
								)
							),
							// Stats grid - 4 columns like production
							React.createElement('div', { className: 'grid grid-cols-2 lg:grid-cols-4 gap-4' },
								// Total Records
								React.createElement('div', { className: 'text-center p-3 bg-gray-50 rounded' },
									React.createElement('div', { className: 'text-2xl font-bold text-blue-600' }, 
										storeData?.totalRecords || sensorRecords?.length || '0'
									),
									React.createElement('div', { className: 'text-sm text-gray-600' }, 'Total Records')
								),
								// Authorized Sensors
								React.createElement('div', { className: 'text-center p-3 bg-gray-50 rounded' },
									React.createElement('div', { className: 'text-2xl font-bold text-green-600' }, '1'),
									React.createElement('div', { className: 'text-sm text-gray-600' }, 'Authorized Sensors')
								),
								// Field Count
								React.createElement('div', { className: 'text-center p-3 bg-gray-50 rounded' },
									React.createElement('div', { className: 'text-2xl font-bold text-purple-600' }, 
										storeData?.fields?.length || '0'
									),
									React.createElement('div', { className: 'text-sm text-gray-600' }, 'Field Count')
								),
								// Owner
								React.createElement('div', { className: 'text-center p-3 bg-gray-50 rounded' },
									React.createElement('div', { className: 'text-sm font-mono text-gray-800' }, 
										storeData?.owner ? `${storeData.owner.slice(0, 6)}...${storeData.owner.slice(-4)}` : 'Loading...'
									),
									React.createElement('div', { className: 'text-sm text-gray-600' }, 'Owner')
								)
							),
							// Description section only (Store Name moved to top)
							storeData?.description && React.createElement('div', { className: 'border-t pt-4 space-y-3' },
								storeData?.description && React.createElement('div', {},
									React.createElement('h3', { className: 'text-sm font-medium text-gray-700 mb-1' }, 'Description'),
									(() => {
										// Parse description for GPS coordinates
										const desc = storeData.description;
										const locMatch = desc.match(/^(.+?)\s+loc:\s*([0-9.-]+),([0-9.-]+)$/);
										
										if (locMatch) {
											const [, location, lat, lng] = locMatch;
											const googleMapsUrl = `https://www.google.com/maps?q=${lat},${lng}`;
											
											return React.createElement('div', { className: 'space-y-2' },
												React.createElement('p', { className: 'text-gray-600' }, location.trim()),
												React.createElement('div', { className: 'flex items-center gap-2 text-sm' },
													React.createElement('span', { className: 'text-gray-500' }, 'GPS:'),
													React.createElement('code', { className: 'bg-gray-100 px-2 py-1 rounded text-xs font-mono' }, `${lat}, ${lng}`),
													React.createElement('a', {
														href: googleMapsUrl,
														target: '_blank',
														rel: 'noopener noreferrer',
														className: 'inline-flex items-center text-blue-600 hover:text-blue-700 text-xs'
													}, 
														'View on Google Maps ',
														React.createElement('svg', {
															className: 'w-3 h-3 ml-1',
															fill: 'none',
															viewBox: '0 0 24 24',
															stroke: 'currentColor'
														},
															React.createElement('path', {
																strokeLinecap: 'round',
																strokeLinejoin: 'round',
																strokeWidth: 2,
																d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
															})
														)
													)
												)
											);
										} else {
											return React.createElement('p', { className: 'text-gray-600' }, desc);
										}
									})()
								),
								// Always show description field even if empty for debugging
								!storeData?.description && React.createElement('div', {},
									React.createElement('h3', { className: 'text-sm font-medium text-gray-700 mb-1' }, 'Description'),
									React.createElement('p', { className: 'text-gray-400 italic' }, 'No description available')
								)
							),
							// External link if available
							storeData?.pointer && React.createElement('div', { className: 'border-t pt-4' },
								React.createElement('a', { 
									href: storeData.pointer,
									target: '_blank',
									rel: 'noopener noreferrer',
									className: 'inline-flex items-center text-blue-600 hover:text-blue-700'
								}, 
									'External Reference '
								)
							)
						)
					),
					
					React.createElement('div', { className: 'grid grid-cols-1 lg:grid-cols-2 gap-6 sm:gap-8' },
						// Left Column: Visualization Only
						React.createElement('div', { className: 'card border rounded-lg p-4' },
							React.createElement('h2', { className: 'text-xl font-semibold mb-3' }, 'Sensor Visualization'),
							sensorRecords.length > 0 ? (
								React.createElement('div', {},
									React.createElement('div', { className: 'flex justify-center' },
										React.createElement(FloodboyVisualization, {
											waterLevel: waterLevel,
											airLevel: installationHeight - waterLevel,
											sensorMode: 'water',
											installationHeight: installationHeight,
											showMeasurement: true,
											isOnline: isOnline && lastUpdated && (Date.now() - lastUpdated.getTime()) < 3600000, // Online if data < 1 hour old
											isDead: lastUpdated && (Date.now() - lastUpdated.getTime()) > 86400000 // Dead if data > 24 hours old
										})
									),
									React.createElement('div', { className: 'text-center text-sm mt-2' },
										waterLevel > installationHeight ? 
											React.createElement('span', { className: 'text-red-600 font-medium' },
												` Water Level: ${waterLevel.toFixed(2)}m (exceeds ${installationHeight.toFixed(2)}m sensor range)`
											) :
											React.createElement('span', { className: 'text-gray-600' },
												`Current Water Level: ${waterLevel.toFixed(2)}m`
											)
									),
									!isOnline && lastUpdated && React.createElement('div', { className: 'text-center text-sm mt-2 text-orange-600' },
										`Last updated: ${lastUpdated.toLocaleString()}`
									)
								)
							) : (
								React.createElement('div', { className: 'flex flex-col items-center justify-center py-12 text-gray-500' },
									React.createElement('div', { className: 'text-6xl mb-4' }, ''),
									React.createElement('h3', { className: 'text-lg font-medium mb-2' }, 'Sensor Not Installed'),
									React.createElement('p', { className: 'text-sm text-center max-w-xs' }, 
										'This sensor has not reported any data yet. Once installed and configured, the visualization will appear here.'
									)
								)
							)
						),
						
						// Right Column: Data Records (Chart/Table) First, then Latest Sensor Data
						React.createElement('div', { className: 'space-y-6' },
							
							// Data Records Section (Chart/Table) - Moved to appear first
							React.createElement(React.Fragment, {},
								// Maximized overlay background - render BEFORE the content
								isMaximized && React.createElement('div', {
									className: 'fixed inset-0 bg-black bg-opacity-50 z-40',									onClick: () => setIsMaximized(false)
								}),
								
								React.createElement('div', { 
									className: `card border rounded-lg p-4 sm:p-6 transition-all duration-300 ${
										isMaximized ? 'fixed inset-4 z-50 bg-white shadow-2xl overflow-auto' : ''
									}`,
									style: isMaximized ? { 
										maxHeight: '90vh',
										animation: 'fadeIn 0.3s ease-out'
									} : {}
								},
									React.createElement('div', { className: 'flex items-center justify-between mb-4' },
									React.createElement('div', {},
										React.createElement('h3', { className: 'text-lg font-semibold flex items-center flex-wrap gap-2' }, 
											React.createElement('span', {}, 'Sensor Data Records'),
											React.createElement('div', { className: 'flex items-center gap-2' },
												sensorRecords.length > 0 && React.createElement('span', { 
													className: 'text-xs px-2 py-1 bg-blue-100 text-blue-700 rounded-full font-normal whitespace-nowrap' 
												}, `${sensorRecords.length} total`),
												activeTab === 'chart' && groupingInterval !== 'none' && sensorRecords.length > 0 && React.createElement('span', { 
													className: 'text-xs px-2 py-1 bg-amber-100 text-amber-700 rounded-full font-normal whitespace-nowrap' 
												}, ` ${(() => {
													const grouped = aggregateDataByInterval([...sensorRecords].sort((a, b) => a.timestamp - b.timestamp), groupingInterval);
													return `${grouped.length} grouped`;
												})()}`),
												currentChain === 8899 && blockNumber && React.createElement('span', { 
													className: 'inline-flex items-center gap-1 text-xs px-2 py-1 bg-green-100 text-green-700 rounded-full font-normal whitespace-nowrap' 
												},
													React.createElement('span', { 
														className: 'inline-block w-2 h-2 bg-green-500 rounded-full animate-pulse' 
													}),
													'Live'
												)
											)
										),
										React.createElement('p', { className: 'text-sm text-gray-600 flex items-center gap-2 flex-wrap' },
											`Showing ${showAllRecords ? sensorRecords.length : Math.min(sensorRecords.length, recordsLimit)} records`,
											loadRange > 0 && React.createElement('span', {
												className: 'text-xs px-2 py-0.5 bg-gray-100 text-gray-600 rounded'
											}, `Last ${loadRange} days`),
											isRefreshing && React.createElement('span', {
												className: 'inline-flex items-center gap-1 text-xs'
											},
												React.createElement('span', {
													className: 'inline-block w-1.5 h-1.5 bg-purple-500 rounded-full animate-pulse'
												}),
												'Updating...'
											),
											isLoadingMore && React.createElement('span', {
												className: 'inline-flex items-center gap-1 text-xs text-blue-600'
											},
												React.createElement('span', {
													className: 'inline-block w-1.5 h-1.5 bg-blue-500 rounded-full animate-pulse'
												}),
												'Loading more...'
											),
											hasMoreData && !isLoadingMore && React.createElement('button', {
												className: 'text-xs px-2 py-0.5 bg-blue-50 text-blue-600 rounded hover:bg-blue-100 transition-colors',
												onClick: async () => {
													setIsLoadingMore(true);
													// Expand time range: 7 -> 30 -> 90 -> all
													const nextRange = loadRange === 7 ? 30 : loadRange === 30 ? 90 : 0;
													setLoadRange(nextRange);
													// Reload will happen via useEffect dependency
												}
											}, loadRange === 7 ? ' Load 30 days' : loadRange === 30 ? ' Load 90 days' : ' Load all')
										)
									),
									React.createElement('div', { className: 'flex items-center gap-2' },
										React.createElement('button', { 
											className: `btn ${activeTab === 'table' ? 'btn-primary' : 'btn-secondary'}`,
											onClick: () => setActiveTab('table')
										}, ' Data Table'),
										React.createElement('button', { 
											className: `btn ${activeTab === 'chart' ? 'btn-primary' : 'btn-secondary'}`,
											onClick: () => setActiveTab('chart')
										}, ' Charts'),
										// Only show Export button when maximized
										isMaximized && React.createElement('button', { 
											className: 'btn btn-success',
											onClick: () => {
												// Export visible records
												const recordsToExport = showAllRecords ? sensorRecords : sensorRecords.slice(0, recordsLimit);
												if (recordsToExport.length > 0 && storeData?.fields) {
													const headers = ['Timestamp', 'Block', ...storeData.fields.map(f => f.name), 'Transaction'];
													const rows = recordsToExport.map(record => [
														new Date(record.timestamp * 1000).toISOString(),
														record.blockNumber || '',
														...storeData.fields.map((field, index) => 
															record.values[index] !== undefined ? formatScaledValue(record.values[index], field.unit) : ''
														),
														record.transactionHash || ''
													]);
													const csv = [headers, ...rows].map(row => row.join(',')).join('\\n');
													const blob = new Blob([csv], { type: 'text/csv' });
													const url = URL.createObjectURL(blob);
													const a = document.createElement('a');
													a.href = url;
													a.download = `sensor-data-${storeAddress.slice(0, 8)}-${new Date().toISOString().split('T')[0]}.csv`;
													a.click();
													URL.revokeObjectURL(url);
												}
											}
										}, ' Export'),
										React.createElement('button', {
											className: `btn ${isMaximized ? 'btn-warning' : 'btn-secondary'}`,
											onClick: () => {
												if (!isMaximized) {
													// When maximizing, default to 100 records
													setRecordsLimit(100);
												}
												setIsMaximized(!isMaximized);
											},
											title: isMaximized ? 'Exit fullscreen (ESC)' : 'Maximize view (Ctrl+F)'
										}, isMaximized ? ' Minimize' : ' Maximize')
									)
								),
								
								// Enhanced statistics when maximized
								isMaximized && sensorRecords.length > 0 && React.createElement('div', { 
									className: 'grid grid-cols-2 md:grid-cols-4 gap-4 mb-4' 
								},
									React.createElement('div', { 
										className: 'bg-blue-50 rounded-lg p-3 cursor-help',
										title: 'Total number of sensor data records stored on blockchain'
									},
										React.createElement('div', { className: 'text-xs text-blue-600 font-medium' }, 'Total Records'),
										React.createElement('div', { className: 'text-2xl font-bold text-blue-700' }, sensorRecords.length)
									),
									React.createElement('div', { className: 'bg-green-50 rounded-lg p-3' },
										React.createElement('div', { className: 'text-xs text-green-600 font-medium' }, 'Time Range'),
										React.createElement('div', { className: 'text-sm font-bold text-green-700' }, 
											sensorRecords.length > 0 ? (() => {
												const oldest = new Date(sensorRecords[sensorRecords.length - 1].timestamp * 1000);
												const newest = new Date(sensorRecords[0].timestamp * 1000);
												const hours = Math.floor((newest - oldest) / (1000 * 60 * 60));
												return hours > 24 ? `${Math.floor(hours / 24)}d ${hours % 24}h` : `${hours}h`;
											})() : '-'
										)
									),
									React.createElement('div', { className: 'bg-purple-50 rounded-lg p-3' },
										React.createElement('div', { className: 'text-xs text-purple-600 font-medium' }, 'Update Frequency'),
										React.createElement('div', { className: 'text-sm font-bold text-purple-700' }, 
											sensorRecords.length > 1 ? (() => {
												// Calculate average time between records
												let totalDiff = 0;
												for (let i = 1; i < Math.min(10, sensorRecords.length); i++) {
													totalDiff += sensorRecords[i-1].timestamp - sensorRecords[i].timestamp;
												}
												const avgSeconds = totalDiff / Math.min(9, sensorRecords.length - 1);
												return avgSeconds < 60 ? `~${Math.round(avgSeconds)}s` : `~${Math.round(avgSeconds / 60)}m`;
											})() : '-'
										)
									),
									React.createElement('div', { className: 'bg-amber-50 rounded-lg p-3' },
										React.createElement('div', { className: 'text-xs text-amber-600 font-medium' }, 'Latest Update'),
										React.createElement('div', { className: 'text-sm font-bold text-amber-700' }, 
											sensorRecords.length > 0 ? (() => {
												const latest = new Date(sensorRecords[0].timestamp * 1000);
												const now = new Date();
												const diffMinutes = Math.floor((now - latest) / (1000 * 60));
												return diffMinutes < 1 ? 'Just now' : 
													   diffMinutes < 60 ? `${diffMinutes}m ago` : 
													   `${Math.floor(diffMinutes / 60)}h ago`;
											})() : '-'
										)
									)
								),
								
								// Show more/less controls when maximized
								isMaximized && sensorRecords.length > 10 && React.createElement('div', { 
									className: 'flex items-center justify-between mb-4 p-3 bg-gray-50 rounded-lg' 
								},
									React.createElement('div', { className: 'flex items-center gap-4' },
										React.createElement('label', { className: 'flex items-center gap-2' },
											React.createElement('input', {
												type: 'checkbox',
												checked: showAllRecords,
												onChange: (e) => setShowAllRecords(e.target.checked),
												className: 'rounded text-blue-600'
											}),
											React.createElement('span', { className: 'text-sm' }, 
												`Show all ${sensorRecords.length} records`
											)
										),
										!showAllRecords && React.createElement('div', { className: 'flex items-center gap-2' },
											React.createElement('label', { className: 'text-sm' }, 'Records per page:'),
											React.createElement('select', {
												value: recordsLimit,
												onChange: (e) => setRecordsLimit(Number(e.target.value)),
												className: 'text-sm border rounded px-2 py-1'
											},
												React.createElement('option', { value: 10 }, '10'),
												React.createElement('option', { value: 25 }, '25'),
												React.createElement('option', { value: 50 }, '50'),
												React.createElement('option', { value: 100 }, '100'),
												React.createElement('option', { value: 250 }, '250'),
												React.createElement('option', { value: 500 }, '500')
											)
										)
									),
									React.createElement('div', { className: 'text-sm text-gray-600' },
										isRefreshing && React.createElement('span', { className: 'flex items-center gap-2' },
											React.createElement('span', { 
												className: 'inline-block w-2 h-2 bg-green-500 rounded-full animate-pulse' 
											}),
											'Live updating...'
										)
									)
								),
								
								// Field selection checkboxes when chart is active
								activeTab === 'chart' && storeData?.fields && React.createElement('div', { 
									className: 'flex flex-wrap items-center justify-between gap-4 mb-4 p-3 bg-gray-50 rounded-lg' 
								},
									React.createElement('div', { className: 'flex flex-wrap gap-3' },
										React.createElement('span', { className: 'text-sm font-medium text-gray-700 self-center mr-2' }, 'Show fields:'),
									storeData.fields
										.filter(field => 
											!field.name.endsWith('_min') && 
											!field.name.endsWith('_max') && 
											!field.name.endsWith('_count')
										)
										.map(field => 
											React.createElement('label', { 
												key: field.name,
												className: `flex items-center gap-2 cursor-pointer px-3 py-2 rounded-lg border-2 transition-all ${
													selectedFields.includes(field.name) 
														? 'bg-blue-100 border-blue-500 text-blue-700' 
														: 'bg-white border-gray-300 text-gray-700 hover:border-gray-400 hover:bg-gray-50'
												}`
											},
												React.createElement('input', {
													type: 'checkbox',
													checked: selectedFields.includes(field.name),
													onChange: (e) => {
														if (e.target.checked) {
															setSelectedFields([...selectedFields, field.name]);
														} else {
															setSelectedFields(selectedFields.filter(f => f !== field.name));
														}
													},
													className: 'w-4 h-4 rounded text-blue-600 focus:ring-blue-500 focus:ring-2'
												}),
												React.createElement('span', { className: 'text-sm font-medium select-none' }, 
													field.name.split('_').map(word => 
														word.charAt(0).toUpperCase() + word.slice(1)
													).join(' ')
												)
											)
										)
									),
									// Scale and grouping toggles
									React.createElement('div', { className: 'flex items-center gap-4' },
										React.createElement('label', { 
											className: `flex items-center gap-2 cursor-pointer px-3 py-2 rounded-lg border-2 transition-all ${
												startFromZero 
													? 'bg-green-100 border-green-500 text-green-700' 
													: 'bg-white border-gray-300 text-gray-700 hover:border-gray-400 hover:bg-gray-50'
											}`
										},
											React.createElement('input', {
												type: 'checkbox',
												checked: startFromZero,
												onChange: (e) => setStartFromZero(e.target.checked),
												className: 'w-4 h-4 rounded text-green-600 focus:ring-green-500 focus:ring-2'
											}),
											React.createElement('span', { className: 'text-sm font-medium select-none' }, 
												'Start Y-axis from 0'
											)
										),
										React.createElement('div', { className: 'flex items-center gap-2' },
											React.createElement('label', { className: 'text-sm font-medium text-gray-700' }, 
												'Group data:'
											),
											React.createElement('select', {
												value: groupingInterval,
												onChange: (e) => setGroupingInterval(e.target.value),
												className: 'text-sm border border-gray-300 rounded px-2 py-1 focus:outline-none focus:ring-2 focus:ring-blue-500'
											},
												React.createElement('option', { value: 'none' }, 'None'),
												React.createElement('option', { value: '15min' }, '15 minutes'),
												React.createElement('option', { value: '30min' }, '30 minutes'),
												React.createElement('option', { value: '1hr' }, '1 hour'),
												React.createElement('option', { value: '3hr' }, '3 hours'),
												React.createElement('option', { value: '6hr' }, '6 hours')
											)
										),
										React.createElement('button', {
											className: `btn btn-secondary ${isRefreshing ? 'opacity-50 cursor-not-allowed' : ''} ml-2`,
											onClick: () => {
												if (!isRefreshing) {
													loadEnhancedStoreData();
												}
											},
											disabled: isRefreshing,
											title: 'Refresh data'
										}, isRefreshing ? ' Loading...' : ' Refresh')
									)
								),
								
								// Content based on active tab
								React.createElement('div', {},
									activeTab === 'table' ? (
										sensorRecords.length > 0 ? React.createElement('div', { className: 'overflow-x-auto -mx-4 sm:-mx-6' },
											(() => {
												// Filter to only show main fields (exclude _min, _max, _count)
												const allMainFields = storeData?.fields?.filter(field => 
													!field.name.endsWith('_min') && 
													!field.name.endsWith('_max') && 
													!field.name.endsWith('_count')
												) || [];
												
												// Create custom ordered fields: Depth, Height, Voltage
												const fieldOrder = ['water_depth', 'installation_height', 'battery_voltage'];
												const orderedFields = [];
												
												// Add fields in the specified order
												fieldOrder.forEach(fieldName => {
													const field = allMainFields.find(f => f.name === fieldName);
													if (field) {
														orderedFields.push(field);
													}
												});
												
												// Add any remaining fields that weren't in the specified order
												allMainFields.forEach(field => {
													if (!fieldOrder.includes(field.name)) {
														orderedFields.push(field);
													}
												});
												
												return React.createElement('div', { className: 'px-4 sm:px-6' },
													React.createElement('table', { className: 'modern-table w-full' },
													React.createElement('thead', {},
														React.createElement('tr', {},
															React.createElement('th', { className: 'text-left' }, 'Timestamp'),
															...orderedFields.map((field, index) => 
																React.createElement('th', { key: index, className: 'text-right', title: `${field.name} (${field.unit})` }, 
																	// Show full field name when maximized, abbreviated when not
																	isMaximized ? 
																		// Full field name with proper formatting
																		field.name.split('_').map(word => 
																			word.charAt(0).toUpperCase() + word.slice(1)
																		).join(' ') :
																		// Abbreviated - only last word
																		field.name.split('_').pop().charAt(0).toUpperCase() + 
																		field.name.split('_').pop().slice(1)
																)
															),
															React.createElement('th', { className: 'text-right' }, 'Block'),
															React.createElement('th', { className: 'text-right' }, 'Tx Hash')
														)
													),
													React.createElement('tbody', {},
														(showAllRecords ? sensorRecords : sensorRecords.slice(0, recordsLimit)).map((record, recordIndex) => 
															React.createElement('tr', { key: recordIndex },
																React.createElement('td', { className: 'text-sm' }, 
																	(() => {
																		const recordDate = new Date(record.timestamp * 1000);
																		// Always show full date and time when maximized
																		if (isMaximized) {
																			return recordDate.toLocaleString('en-US', {
																				year: 'numeric',
																				month: '2-digit',
																				day: '2-digit',
																				hour: '2-digit',
																				minute: '2-digit',
																				second: '2-digit',
																				hour12: false
																			});
																		}
																		// Original logic for non-maximized view
																		const today = new Date();
																		const isToday = recordDate.toDateString() === today.toDateString();
																		
																		if (isToday) {
																			// Show only time for today's records
																			return recordDate.toLocaleTimeString();
																		} else {
																			// Show full date and time for older records
																			return recordDate.toLocaleString();
																		}
																	})()
																),
																...orderedFields.map((field, fieldIndex) => {
																	// Find the actual index in the original fields array
																	const actualIndex = storeData.fields.findIndex(f => f.name === field.name);
																	return React.createElement('td', { key: fieldIndex, className: 'font-medium text-sm text-right' }, 
																		record.values[actualIndex] !== undefined ? 
																			formatScaledValue(record.values[actualIndex], field.unit) : 
																			'-'
																	);
																}),
																React.createElement('td', { className: 'text-sm text-right' }, 
																	record.blockNumber ? record.blockNumber.toString() : '-'
																),
																React.createElement('td', { className: 'text-sm text-right font-mono' }, 
																	record.transactionHash ? 
																		React.createElement('a', { 
																			href: `${getExplorerUrl(currentChain)}/tx/${record.transactionHash}`,
																			target: '_blank',
																			className: 'text-blue-600 hover:text-blue-800 hover:underline',
																			title: `Transaction: ${record.transactionHash}`
																		}, formatAddress(record.transactionHash))
																		: '-'
																)
															)
														)
													)
												)
												);
											})()
										) : React.createElement('div', { className: 'text-center text-gray-500 py-8' },
											'No sensor data records found'
										)
									) : activeTab === 'chart' ? (
										sensorRecords.length > 0 ? React.createElement('div', { 
											style: { height: '400px', width: '100%', position: 'relative' }
										},
											React.createElement('canvas', { 
												ref: chartRef,
												style: { maxHeight: '400px' }
											})
										) : React.createElement('div', { className: 'text-center text-gray-500 py-8' },
											'No data available for chart'
										)
									) : null
								)
							)
						),
						
						// Latest Sensor Data Section - Moved to appear after Data Records
						React.createElement('div', { className: 'card border rounded-lg p-6' },
							React.createElement('div', { className: 'mb-4' },
								React.createElement('div', { className: 'flex justify-between items-start' },
									React.createElement('div', {},
										React.createElement('h3', { className: 'text-lg font-semibold' }, 'Latest Sensor Data'),
										React.createElement('a', { 
											href: `${getExplorerUrl(currentChain)}/address/${storeAddress}`,
											target: '_blank',
											rel: 'noopener noreferrer',
											className: 'text-sm text-gray-500 hover:text-purple-600 font-mono inline-flex items-center mt-1'
										},
											formatAddress(storeAddress),
											React.createElement('svg', { 
												className: 'w-3 h-3 ml-1',
												fill: 'none',
												stroke: 'currentColor',
												viewBox: '0 0 24 24'
											},
												React.createElement('path', {
													strokeLinecap: 'round',
													strokeLinejoin: 'round',
													strokeWidth: 2,
													d: 'M10 6H6a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4M14 4h6m0 0v6m0-6L10 14'
												})
											)
										)
									),
									sensorRecords.length > 0 && React.createElement('div', { className: 'text-right' },
									// Block indicator for JBC chain (first line)
									currentChain === 8899 && blockNumber && React.createElement('div', { className: 'flex items-center justify-end' },
										React.createElement('span', { 
											className: `w-2 h-2 ${
												blockTimer >= 10 ? 'bg-yellow-500' : 'bg-green-500'
											} rounded-full mr-2 animate-pulse`
										}),
										React.createElement('span', { className: 'text-sm text-gray-600' }, 'Current Block:'),
										React.createElement('span', { className: 'text-sm font-mono text-purple-600 ml-1' }, 
											blockNumber.toString()
										),
										showBlockIndicator && React.createElement('span', { 
											className: `text-xs ml-1 font-semibold ${
												blockTimer >= 10 ? 'text-yellow-600' : 'text-green-600'
											}`
										}, `(${blockTimer}s)`)
									),
									// Updated timestamp (second line)
									React.createElement('div', { className: 'text-sm text-gray-500 mt-1' },
										lastUpdated ? (() => {
											const today = new Date();
											const isToday = lastUpdated.toDateString() === today.toDateString();
											
											if (isToday) {
												return `Updated: ${lastUpdated.toLocaleTimeString()}`;
											} else {
												return `Updated: ${lastUpdated.toLocaleString()}`;
											}
										})() : ''
									)
								)
								)
							),
							React.createElement('div', { className: 'overflow-x-auto' },
								// Group fields by base name for compact table display
								(() => {
									if (!storeData?.fields || storeData.fields.length === 0) {
										// Fallback display
										return React.createElement('div', { className: 'space-y-3' }, [
											React.createElement('div', { key: 'water', className: 'bg-blue-50 p-4 rounded-lg' },
												React.createElement('div', { className: 'text-sm text-blue-600 font-medium' }, 'Water Level'),
												React.createElement('div', { className: 'text-2xl font-bold text-blue-900' }, `${waterLevel.toFixed(2)} m`)
											),
											React.createElement('div', { key: 'temp', className: 'bg-green-50 p-4 rounded-lg' },
												React.createElement('div', { className: 'text-sm text-green-600 font-medium' }, 'Temperature'),
												React.createElement('div', { className: 'text-2xl font-bold text-green-900' }, `${temperature.toFixed(1)} C`)
											)
										]);
									}
									
									// Group fields by base name
									const fieldGroups = {};
									
									storeData.fields.forEach((field, index) => {
										// Skip _min, _max, _count fields - we'll collect them under their base name
										if (field.name.endsWith('_min') || field.name.endsWith('_max') || field.name.endsWith('_count')) {
											return;
										}
										
										// This is a main field
										const baseName = field.name;
										
										if (!fieldGroups[baseName]) {
											fieldGroups[baseName] = { baseName, fields: {} };
										}
										
										// Store the main field
										fieldGroups[baseName].fields.main = {
											field,
											index,
											value: sensorRecords.length > 0 && sensorRecords[0].values[index] !== undefined
												? parseFloat(formatScaledValue(sensorRecords[0].values[index], field.unit))
												: null
										};
										
										// Look for related _min, _max, _count fields
										storeData.fields.forEach((relatedField, relatedIndex) => {
											if (relatedField.name === baseName + '_min') {
												fieldGroups[baseName].fields.min = {
													field: relatedField,
													index: relatedIndex,
													value: sensorRecords.length > 0 && sensorRecords[0].values[relatedIndex] !== undefined
														? parseFloat(formatScaledValue(sensorRecords[0].values[relatedIndex], relatedField.unit))
														: null
												};
											} else if (relatedField.name === baseName + '_max') {
												fieldGroups[baseName].fields.max = {
													field: relatedField,
													index: relatedIndex,
													value: sensorRecords.length > 0 && sensorRecords[0].values[relatedIndex] !== undefined
														? parseFloat(formatScaledValue(sensorRecords[0].values[relatedIndex], relatedField.unit))
														: null
												};
											} else if (relatedField.name === baseName + '_count') {
												fieldGroups[baseName].fields.count = {
													field: relatedField,
													index: relatedIndex,
													value: sensorRecords.length > 0 && sensorRecords[0].values[relatedIndex] !== undefined
														? parseFloat(formatScaledValue(sensorRecords[0].values[relatedIndex], relatedField.unit))
														: null
												};
											}
										});
									});
									
									// Convert to array and sort
									const sortedGroups = Object.values(fieldGroups).sort((a, b) => {
										// Priority order for known fields
										const priority = {
											'battery_voltage': 1,
											'installation_height': 2,
											'water_depth': 3,
											'water_level': 4
										};
										return (priority[a.baseName] || 999) - (priority[b.baseName] || 999);
									});
									
									// Render compact table
									return React.createElement('table', { className: 'w-full' },
										React.createElement('thead', {},
											React.createElement('tr', { className: 'border-b' },
												React.createElement('th', { className: 'text-left py-3 px-4 text-sm font-semibold text-gray-700' }, 'Metric'),
												React.createElement('th', { className: 'text-right py-3 px-4 text-sm font-semibold text-gray-700' }, 'Current'),
												React.createElement('th', { className: 'text-right py-3 px-4 text-sm font-semibold text-gray-700' }, 'Min'),
												React.createElement('th', { className: 'text-right py-3 px-4 text-sm font-semibold text-gray-700' }, 'Max')
											)
										),
										React.createElement('tbody', {},
											sortedGroups.map((group, groupIndex) => {
												const main = group.fields.main;
												const min = group.fields.min;
												const max = group.fields.max;
												const count = group.fields.count;
												
												// Clean unit display
												const unit = main.field.unit.replace(/\s*x\s*\d+/gi, '').trim();
												
												// Format display name
												const displayName = group.baseName
													.replace(/_/g, ' ')
													.replace(/\b\w/g, l => l.toUpperCase());
												
												// Color for rows
												const colors = ['bg-blue-50', 'bg-green-50', 'bg-purple-50', 'bg-yellow-50'];
												const rowColor = colors[groupIndex % colors.length];
												
												// Format value helper
												const formatValue = (val, isCount = false) => {
													if (val === null) return 'No data';
													if (isCount || unit.toLowerCase().includes('count')) {
														return `${Math.round(val)}`;
													}
													return val.toFixed(unit.includes('V') ? 3 : unit.includes('m') ? 4 : 2);
												};
												
												// Check if water level exceeds sensor range
												const isWaterLevel = group.baseName.toLowerCase().includes('water');
												const mainValue = main.value;
												const exceedsSensorRange = mainValue !== null && isWaterLevel && mainValue > installationHeight;
												
												return React.createElement('tr', { 
													key: groupIndex,
													className: `${rowColor} ${exceedsSensorRange ? 'bg-red-50' : ''} border-b`
												},
													React.createElement('td', { 
														className: `py-3 px-4 text-sm font-medium ${exceedsSensorRange ? 'text-red-700' : 'text-gray-900'}`
													}, 
														displayName,
														count && React.createElement('span', { 
															className: 'ml-2 px-2 py-1 text-xs font-medium bg-blue-100 text-blue-700 rounded-full'
														}, `${Math.round(count.value)} samples`)
													),
													React.createElement('td', { 
														className: `py-3 px-4 text-right font-bold ${
															mainValue !== null 
																? exceedsSensorRange ? 'text-red-900' : 'text-gray-900' 
																: 'text-gray-400 italic'
														}`
													}, 
														formatValue(mainValue),
														mainValue !== null && ` ${unit}`,
														exceedsSensorRange && ' '
													),
													React.createElement('td', { 
														className: `py-3 px-4 text-right text-sm ${
															min?.value !== null ? 'text-gray-700' : 'text-gray-400'
														}`
													}, 
														min ? [
															formatValue(min.value),
															min.value !== null && ` ${unit}`
														] : ''
													),
													React.createElement('td', { 
														className: `py-3 px-4 text-right text-sm ${
															max?.value !== null ? 'text-gray-700' : 'text-gray-400'
														}`
													}, 
														max ? [
															formatValue(max.value),
															max.value !== null && ` ${unit}`
														] : ''
													)
												);
											})
										)
									);
								})(),
								
								lastUpdated && React.createElement('div', { className: 'bg-gray-50 p-3 rounded-lg mt-4' },
									React.createElement('div', { className: 'text-xs text-gray-600' }, 'Last Updated'),
									React.createElement('div', { className: 'text-sm font-medium text-gray-800' }, 
										lastUpdated.toLocaleString()
									)
								)
							)
						)
					),

						// Cat Lab inspired sections
						// Field Schema Section (Cat Lab style)
						React.createElement('div', { className: 'card rounded-xl p-6' },
							React.createElement('div', { className: 'flex items-center justify-between mb-4' },
								React.createElement('h3', { className: 'text-lg font-semibold' }, 'Field Schema'),
								React.createElement('div', { className: 'text-sm text-gray-600' }, 
									`${storeData.fields.length} Field${storeData.fields.length !== 1 ? 's' : ''}`
								)
							),
							React.createElement('div', { className: 'text-sm text-gray-600 mb-4' }, 'Data structure and field definitions for this store'),
							React.createElement('div', { className: 'space-y-3' },
								storeData.fields.map((field, index) => 
									React.createElement('div', { 
										key: index, 
										className: 'flex items-center justify-between p-4 bg-gray-50 rounded-lg border-l-4 border-blue-500 hover:shadow-md transition-shadow' 
									},
										React.createElement('div', { className: 'flex items-center gap-4' },
											React.createElement('span', { className: 'font-bold text-gray-700' }, index),
											React.createElement('span', { className: 'font-mono' }, field.name)
										),
										React.createElement('div', { className: 'flex flex-wrap gap-2' },
											React.createElement('span', { 
												className: 'px-2 py-1 bg-blue-600 text-white rounded text-xs font-mono' 
											}, field.unit),
											React.createElement('span', { 
												className: 'px-2 py-1 bg-purple-600 text-white rounded text-xs' 
											}, field.dtype)
										)
									)
								)
							)
						),

					)
				);
			}

			// Render the app
			const root = ReactDOM.createRoot(document.getElementById('blockchain-app'));
			root.render(React.createElement(BlockchainApp));
		</script>
	</body>
</html>
