---
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../consts';
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={`Blockchain Dashboard | ${SITE_TITLE}`} description={SITE_DESCRIPTION} />
		
		<!-- React and Babel for JSX -->
		<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
		<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
		<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
		
		<!-- p5.js -->
		<script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
		
		<!-- Chart.js -->
		<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/date-fns@2.29.3/index.min.js"></script>
		<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0/dist/chartjs-adapter-date-fns.bundle.min.js"></script>
		
		<!-- Tailwind CSS -->
		<script src="https://cdn.tailwindcss.com"></script>
		
		<style>
			body {
				margin: 0;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
				transition: background-color 0.3s, color 0.3s;
			}
			body.dark {
				background-color: #0f0f0f;
				color: #ffffff;
			}
			body.light {
				background-color: #f3f4f6;
				color: #1f2937;
			}
			#p5-container {
				border: 2px solid #1f2937;
				border-radius: 8px;
				overflow: hidden;
				background: rgba(17, 24, 39, 0.5);
			}
			body.light #p5-container {
				border: 2px solid #e5e7eb;
				background: rgba(255, 255, 255, 0.8);
			}
			.loading-skeleton {
				animation: pulse 2s cubic-bezier(0.4, 0, 0.6, 1) infinite;
			}
			@keyframes pulse {
				0%, 100% { opacity: 1; }
				50% { opacity: .5; }
			}
			.theme-switcher {
				position: fixed;
				top: 20px;
				right: 20px;
				z-index: 50;
			}
		</style>
	</head>
	<body>
		<Header />
		<main>
			<div id="blockchain-app"></div>
		</main>
		<Footer />

		<script type="module">
			// Import viem modules
			import { createPublicClient, http, parseAbi, formatEther, createWalletClient, custom, decodeEventLog } from 'https://esm.sh/viem@2.21.19';
			import { mainnet, sepolia, anvil } from 'https://esm.sh/viem@2.21.19/chains';
			
			// Custom chain configurations
			const jibchainL1 = {
				id: 8899,
				name: 'JIBCHAIN L1',
				network: 'jibchain',
				nativeCurrency: { name: 'JBC', symbol: 'JBC', decimals: 18 },
				rpcUrls: {
					default: { http: ['https://rpc-l1.jbc.xpool.pw'] },
					public: { http: ['https://rpc-l1.jbc.xpool.pw'] }
				},
				blockExplorers: {
					default: { name: 'JBC Explorer', url: 'https://exp.jibchain.net' }
				}
			};
			
			const sichang = {
				id: 700011,
				name: 'SiChang',
				network: 'sichang',
				nativeCurrency: { name: 'TCH', symbol: 'TCH', decimals: 18 },
				rpcUrls: {
					default: { http: ['https://sichang-rpc.thaichain.org'] },
					public: { http: ['https://sichang-rpc.thaichain.org'] }
				},
				blockExplorers: {
					default: { name: 'SiChang Explorer', url: 'https://sichang.thaichain.org' }
				}
			};
			
			// Make viem and chains available globally
			window.viem = { createPublicClient, http, parseAbi, formatEther, createWalletClient, custom, decodeEventLog };
			window.chains = { mainnet, sepolia, anvil, jibchainL1, sichang };

			// Contract ABIs
			const DEPLOYER_ABI = [
				{
					"inputs": [{"internalType": "address", "name": "user", "type": "address"}],
					"name": "getUserStores",
					"outputs": [{"internalType": "address[]", "name": "", "type": "address[]"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [{"internalType": "address", "name": "store", "type": "address"}],
					"name": "storeToNickname",
					"outputs": [{"internalType": "string", "name": "", "type": "string"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [{"internalType": "address", "name": "store", "type": "address"}],
					"name": "getStoreMetadata",
					"outputs": [
						{"internalType": "uint256", "name": "deployedBlock", "type": "uint256"},
						{"internalType": "uint256", "name": "lastUpdatedBlock", "type": "uint256"},
						{"internalType": "string", "name": "description", "type": "string"},
						{"internalType": "string", "name": "pointer", "type": "string"}
					],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"anonymous": false,
					"inputs": [
						{"indexed": true, "internalType": "address", "name": "creator", "type": "address"},
						{"indexed": false, "internalType": "address", "name": "store", "type": "address"},
						{"indexed": false, "internalType": "string", "name": "nickname", "type": "string"}
					],
					"name": "SensorStoreDeployed",
					"type": "event"
				}
			];

			const STORE_ABI = [
				{
					"inputs": [],
					"name": "getAllFields",
					"outputs": [
						{
							"components": [
								{"internalType": "string", "name": "name", "type": "string"},
								{"internalType": "string", "name": "unit", "type": "string"},
								{"internalType": "string", "name": "dtype", "type": "string"}
							],
							"internalType": "struct SensorDataStore.Field[]",
							"name": "",
							"type": "tuple[]"
						}
					],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [{"internalType": "address", "name": "sensor", "type": "address"}],
					"name": "getLatestRecord",
					"outputs": [
						{"internalType": "uint256", "name": "timestamp", "type": "uint256"},
						{"internalType": "int256[]", "name": "values", "type": "int256[]"}
					],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [],
					"name": "owner",
					"outputs": [{"internalType": "address", "name": "", "type": "address"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [{"internalType": "address", "name": "sensor", "type": "address"}],
					"name": "isSensorAuthorized",
					"outputs": [{"internalType": "bool", "name": "", "type": "bool"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"anonymous": false,
					"inputs": [
						{"indexed": true, "internalType": "address", "name": "sensor", "type": "address"},
						{"indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256"},
						{"indexed": false, "internalType": "int256[]", "name": "values", "type": "int256[]"}
					],
					"name": "RecordStored",
					"type": "event"
				},
				{
					"anonymous": false,
					"inputs": [{"indexed": true, "internalType": "address", "name": "sensor", "type": "address"}],
					"name": "SensorAuthorized",
					"type": "event"
				},
				{
					"anonymous": false,
					"inputs": [{"indexed": true, "internalType": "address", "name": "sensor", "type": "address"}],
					"name": "SensorRevoked",
					"type": "event"
				}
			];

			// Chain configurations
			const chainConfigs = {
				8899: {
					name: 'JIBCHAIN L1',
					chain: jibchainL1,
					deployerAddress: '0x5cEe5489DdB5006e5c1c1f2029bc7451E4A25837',
					explorerUrl: 'https://exp.jibchain.net'
				},
				700011: {
					name: 'SiChang',
					chain: sichang,
					deployerAddress: '0x0000000000000000000000000000000000000000',
					explorerUrl: 'https://sichang.thaichain.org'
				},
				31337: {
					name: 'Anvil',
					chain: anvil,
					deployerAddress: '0xDc64a140Aa3E981100a9becA4E685f962f0cF6C9',
					explorerUrl: 'http://localhost:8545'
				}
			};

			const exampleStores = {
				8899: [
					{ address: '0xc887E6FEdF2879ca0731F9b5d3D077F43f53D6e8', description: 'Latest with metadata' },
					{ address: '0x3b83A7Ba23bf71946739E96200e947cc827918d9', description: 'Alternative store' }
				],
				700011: [],
				31337: []
			};

			const testAddresses = [
				'0xDE06Fd88f43F616c65a2274DC67ff53FDdE67c84',
				'0x76Bf2C3D38DfE6ECc7d17886bBed1193970b346e'
			];

			// Make configurations available globally
			window.DEPLOYER_ABI = DEPLOYER_ABI;
			window.STORE_ABI = STORE_ABI;
			window.chainConfigs = chainConfigs;
			window.exampleStores = exampleStores;
			window.testAddresses = testAddresses;
		</script>

		<script type="text/babel">
			const { useState, useEffect, useRef } = React;
			const { createPublicClient, http, parseAbi, formatEther, createWalletClient, custom, decodeEventLog } = window.viem;
			const { mainnet, sepolia, anvil, jibchainL1, sichang } = window.chains;

			// Component definitions will go here
			const LoadingSkeleton = ({ lines = 3 }) => (
				<div className="space-y-2">
					{Array.from({ length: lines }, (_, i) => (
						<div key={i} className="loading-skeleton h-4 bg-gray-300 rounded" />
					))}
				</div>
			);

			const ErrorDisplay = ({ error, onRetry }) => (
				<div className="bg-red-900/20 border border-red-400 text-red-700 px-4 py-3 rounded">
					<div className="flex items-center justify-between">
						<span>{error}</span>
						{onRetry && (
							<button onClick={onRetry} className="ml-4 text-sm underline">
								Retry
							</button>
						)}
					</div>
				</div>
			);

			// Floodboy Visualization Component
			const FloodboyVisualization = ({ storeData, currentBlock }) => {
				const containerRef = useRef(null);
				const p5InstanceRef = useRef(null);

				useEffect(() => {
					if (!containerRef.current || p5InstanceRef.current) return;

					let waterLevel = 0;
					let airLevel = 2.5;
					let installationHeight = 3.0;
					let ripples = [];
					let lastUpdateTime = 0;

					const sketch = (p) => {
						p.setup = () => {
							const canvas = p.createCanvas(350, 420);
							canvas.parent(containerRef.current);
							p.frameRate(30);
						};

						p.draw = () => {
							p.clear();
							p.background(255, 255, 255, 0);

							// Extract sensor data if available
							if (storeData?.sensorRecords?.[0]?.latestRecord) {
								const latestRecord = storeData.sensorRecords[0].latestRecord;
								const waterIdx = storeData.fields.findIndex(f => f.name === 'water_depth');
								const airIdx = storeData.fields.findIndex(f => f.name === 'air_height');
								const installIdx = storeData.fields.findIndex(f => f.name === 'installation_height');

								if (waterIdx !== -1) waterLevel = parseInt(latestRecord.values[waterIdx]) / 1000;
								if (airIdx !== -1) airLevel = parseInt(latestRecord.values[airIdx]) / 1000;
								if (installIdx !== -1) installationHeight = parseInt(latestRecord.values[installIdx]) / 1000;
							}

							// Draw the visualization
							drawFloodboyVisualization(p, waterLevel, airLevel, installationHeight, ripples);
						};
					};

					const drawFloodboyVisualization = (p, waterLevel, airLevel, installationHeight, ripples) => {
						// Draw foundation
						p.fill(120, 120, 120);
						p.rect(50, 350, 250, 50);

						// Draw pole
						p.fill(100, 100, 100);
						p.rect(140, 100, 20, 250);

						// Draw solar panel
						p.fill(30, 60, 120);
						p.rect(90, 80, 120, 40);
						p.stroke(255);
						for (let i = 0; i < 4; i++) {
							p.line(90 + i * 30, 80, 90 + i * 30, 120);
						}
						p.noStroke();

						// Draw control box
						p.fill(60, 60, 60);
						p.rect(120, 130, 60, 40);
						p.fill(255);
						p.textAlign(p.CENTER);
						p.textSize(8);
						p.text('FLOODBOY', 150, 145);

						// Draw LED status (green for online, red for offline)
						const now = Date.now() / 1000;
						const isOnline = storeData?.sensorRecords?.[0]?.latestRecord?.timestamp ? 
							(now - storeData.sensorRecords[0].latestRecord.timestamp) < 3600 : false;
						
						p.fill(isOnline ? p.color(0, 255, 0) : p.color(255, 0, 0));
						p.circle(135, 160, 6);

						// Draw telescopic arm
						p.fill(80, 80, 80);
						p.rect(160, 145, 100, 10);
						p.rect(250, 140, 20, 20);

						// Draw sensor
						p.fill(40, 40, 40);
						p.rect(270, 135, 15, 30);

						// Draw water/ground
						const groundLevel = 350;
						const actualWaterLevel = waterLevel > 0 ? groundLevel - (waterLevel * 50) : groundLevel;

						if (waterLevel > 0) {
							// Draw water
							p.fill(100, 150, 255, 180);
							p.rect(0, actualWaterLevel, p.width, groundLevel - actualWaterLevel);
							
							// Draw ripples
							p.stroke(255, 255, 255, 100);
							p.strokeWeight(2);
							for (let ripple of ripples) {
								p.noFill();
								p.circle(ripple.x, ripple.y, ripple.size);
								ripple.size += 2;
								if (ripple.size > 100) ripples.splice(ripples.indexOf(ripple), 1);
							}
							p.noStroke();

							// Add new ripples occasionally
							if (p.frameCount % 60 === 0) {
								ripples.push({ x: p.random(50, 300), y: actualWaterLevel + 10, size: 10 });
							}
						} else {
							// Draw dry ground
							p.fill(139, 69, 19);
							p.rect(0, groundLevel, p.width, 50);
						}

						// Draw measurement line
						if (airLevel > 0) {
							p.stroke(255, 255, 0);
							p.strokeWeight(2);
							p.drawingContext.setLineDash([5, 5]);
							p.line(285, 150, 285, actualWaterLevel);
							p.drawingContext.setLineDash([]);
							p.noStroke();

							// Display measurement
							p.fill(0);
							p.textAlign(p.LEFT);
							p.textSize(12);
							p.text(`${waterLevel.toFixed(2)}m`, 290, 250);
						}

						// Display current block
						if (currentBlock) {
							p.fill(0);
							p.textAlign(p.LEFT);
							p.textSize(10);
							p.text(`Block: ${currentBlock}`, 10, 20);
						}
					};

					p5InstanceRef.current = new p5(sketch);

					return () => {
						if (p5InstanceRef.current) {
							p5InstanceRef.current.remove();
							p5InstanceRef.current = null;
						}
					};
				}, []);

				return <div ref={containerRef} id="p5-container" className="mx-auto" />;
			};

			// Main App Component
			const App = () => {
				const [walletClient, setWalletClient] = useState(null);
				const [publicClient, setPublicClient] = useState(null);
				const [account, setAccount] = useState(null);
				const [chainId, setChainId] = useState(8899);
				const [selectedChain, setSelectedChain] = useState(8899);
				const [stores, setStores] = useState([]);
				const [selectedStore, setSelectedStore] = useState(null);
				const [storeData, setStoreData] = useState(null);
				const [viewMode, setViewMode] = useState('direct');
				const [publicAddress, setPublicAddress] = useState('');
				const [directStoreAddress, setDirectStoreAddress] = useState('0xc887E6FEdF2879ca0731F9b5d3D077F43f53D6e8');
				const [theme, setTheme] = useState('light');
				const [loading, setLoading] = useState(false);
				const [initialLoad, setInitialLoad] = useState(true);
				const [error, setError] = useState(null);
				const [currentBlock, setCurrentBlock] = useState(null);
				const [blockNumber, setBlockNumber] = useState(null);
				const [blockTimer, setBlockTimer] = useState(0);
				const [showBlockIndicator, setShowBlockIndicator] = useState(true);

				// Theme management
				useEffect(() => {
					document.body.className = theme;
				}, [theme]);

				// Initialize public client when chain changes
				useEffect(() => {
					const config = chainConfigs[selectedChain];
					if (!config) return;

					const client = createPublicClient({
						chain: config.chain,
						transport: http()
					});

					setPublicClient(client);
					setChainId(selectedChain);
				}, [selectedChain]);

				// Auto-load store data when client is ready
				useEffect(() => {
					if (publicClient && initialLoad && directStoreAddress) {
						loadStoreData(directStoreAddress);
						setInitialLoad(false);
					}
				}, [publicClient, initialLoad, directStoreAddress]);

				// Block number monitoring
				useEffect(() => {
					if (!publicClient) return;

					const updateBlockNumber = async () => {
						try {
							const block = await publicClient.getBlockNumber();
							setCurrentBlock(Number(block));
							setBlockNumber(Number(block));
						} catch (err) {
							console.error('Failed to get block number:', err);
						}
					};

					updateBlockNumber();
					const interval = setInterval(updateBlockNumber, chainId === 8899 ? 1000 : 5000);

					return () => clearInterval(interval);
				}, [publicClient, chainId]);

				const loadStoreData = async (storeAddress) => {
					if (!publicClient || !storeAddress) return;

					setLoading(true);
					setError(null);

					try {
						// Get store fields
						const fields = await publicClient.readContract({
							address: storeAddress,
							abi: STORE_ABI,
							functionName: 'getAllFields'
						});

						// Get store owner
						const owner = await publicClient.readContract({
							address: storeAddress,
							abi: STORE_ABI,
							functionName: 'owner'
						});

						// Get events to find sensor data
						const eventAbi = parseAbi(['event RecordStored(address indexed sensor, uint256 timestamp, int256[] values)'])[0];
						
						const events = await publicClient.getLogs({
							address: storeAddress,
							event: eventAbi,
							fromBlock: 'earliest',
							toBlock: 'latest'
						});

						// Process events to get sensor records
						const sensorRecords = {};
						
						events.forEach(event => {
							const decoded = decodeEventLog({
								abi: [eventAbi],
								data: event.data,
								topics: event.topics
							});

							const sensor = decoded.args.sensor;
							const timestamp = parseInt(decoded.args.timestamp);
							const values = decoded.args.values.map(v => Number(v));

							if (!sensorRecords[sensor] || sensorRecords[sensor].latestRecord.timestamp < timestamp) {
								sensorRecords[sensor] = {
									sensor,
									totalRecords: (sensorRecords[sensor]?.totalRecords || 0) + 1,
									latestRecord: { timestamp, values }
								};
							} else {
								sensorRecords[sensor].totalRecords++;
							}
						});

						setStoreData({
							address: storeAddress,
							fields: fields.map(f => ({ name: f.name, unit: f.unit, dtype: f.dtype })),
							owner,
							sensorRecords: Object.values(sensorRecords)
						});

					} catch (err) {
						console.error('Failed to load store data:', err);
						setError(err.message);
					} finally {
						setLoading(false);
					}
				};

				const connectWallet = async () => {
					if (!window.ethereum) {
						setError('MetaMask not detected');
						return;
					}

					try {
						const walletClient = createWalletClient({
							chain: chainConfigs[selectedChain].chain,
							transport: custom(window.ethereum)
						});

						const accounts = await walletClient.requestAddresses();
						setWalletClient(walletClient);
						setAccount(accounts[0]);
					} catch (err) {
						setError(err.message);
					}
				};

				return (
					<div className="min-h-screen transition-colors duration-300">
						{/* Theme Switcher */}
						<div className="theme-switcher">
							<button
								onClick={() => setTheme(theme === 'light' ? 'dark' : 'light')}
								className="px-3 py-1 rounded-md bg-gray-200 dark:bg-gray-700 text-gray-800 dark:text-gray-200 hover:bg-gray-300 dark:hover:bg-gray-600 transition-colors"
							>
								{theme === 'light' ? 'üåô' : '‚òÄÔ∏è'}
							</button>
						</div>

						{/* Block Indicator */}
						{showBlockIndicator && currentBlock && (
							<div className="fixed top-20 right-20 bg-gray-800 text-white px-3 py-1 rounded-md text-sm z-40">
								Block: {currentBlock}
							</div>
						)}

						<div className="container mx-auto px-4 py-8">
							<h1 className="text-3xl font-bold mb-8 text-center">IoT Factory - Smart Contract Dashboard</h1>

							{/* View Mode Tabs */}
							<div className="flex justify-center mb-8">
								<div className="flex space-x-1 bg-gray-200 dark:bg-gray-700 rounded-lg p-1">
									{['public', 'direct', 'wallet'].map(mode => (
										<button
											key={mode}
											onClick={() => setViewMode(mode)}
											className={`px-4 py-2 rounded-md capitalize transition-colors ${
												viewMode === mode
													? 'bg-purple-600 text-white'
													: 'text-gray-700 dark:text-gray-300 hover:bg-gray-300 dark:hover:bg-gray-600'
											}`}
										>
											{mode}
										</button>
									))}
								</div>
							</div>

							{/* Chain Selection */}
							<div className="flex justify-center mb-8">
								<select
									value={selectedChain}
									onChange={(e) => setSelectedChain(parseInt(e.target.value))}
									className="px-4 py-2 rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
								>
									{Object.entries(chainConfigs).map(([id, config]) => (
										<option key={id} value={id}>
											{config.name}
										</option>
									))}
								</select>
							</div>

							{/* Direct Store Address Input */}
							{viewMode === 'direct' && (
								<div className="max-w-2xl mx-auto mb-8">
									<div className="flex space-x-2">
										<input
											type="text"
											value={directStoreAddress}
											onChange={(e) => setDirectStoreAddress(e.target.value)}
											placeholder="Enter store address..."
											className="flex-1 px-4 py-2 rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
										/>
										<button
											onClick={() => loadStoreData(directStoreAddress)}
											disabled={loading}
											className="px-6 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 disabled:opacity-50"
										>
											Load Store
										</button>
									</div>
									
									{/* Example stores */}
									{exampleStores[selectedChain]?.length > 0 && (
										<div className="mt-4">
											<p className="text-sm text-gray-600 dark:text-gray-400 mb-2">Example stores:</p>
											<div className="space-x-2">
												{exampleStores[selectedChain].map((store, i) => (
													<button
														key={i}
														onClick={() => {
															setDirectStoreAddress(store.address);
															loadStoreData(store.address);
														}}
														className="text-sm px-3 py-1 bg-gray-200 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600"
													>
														{store.description}
													</button>
												))}
											</div>
										</div>
									)}
								</div>
							)}

							{/* Wallet Mode */}
							{viewMode === 'wallet' && (
								<div className="max-w-md mx-auto mb-8 text-center">
									{!account ? (
										<button
											onClick={connectWallet}
											className="px-6 py-3 bg-purple-600 text-white rounded-lg hover:bg-purple-700"
										>
											Connect Wallet
										</button>
									) : (
										<div className="bg-green-100 dark:bg-green-900 border border-green-400 rounded-lg p-4">
											<p className="text-green-800 dark:text-green-200">
												Connected: {account.slice(0, 6)}...{account.slice(-4)}
											</p>
										</div>
									)}
								</div>
							)}

							{/* Public Address Mode */}
							{viewMode === 'public' && (
								<div className="max-w-2xl mx-auto mb-8">
									<div className="flex space-x-2">
										<input
											type="text"
											value={publicAddress}
											onChange={(e) => setPublicAddress(e.target.value)}
											placeholder="Enter address to view stores..."
											className="flex-1 px-4 py-2 rounded-md border border-gray-300 dark:border-gray-600 bg-white dark:bg-gray-800 text-gray-900 dark:text-gray-100"
										/>
										<button
											onClick={() => {/* loadPublicStores(publicAddress) */}}
											disabled={loading}
											className="px-6 py-2 bg-purple-600 text-white rounded-md hover:bg-purple-700 disabled:opacity-50"
										>
											View Stores
										</button>
									</div>
									
									{/* Test addresses */}
									<div className="mt-4">
										<p className="text-sm text-gray-600 dark:text-gray-400 mb-2">Test addresses:</p>
										<div className="space-x-2">
											{testAddresses.map((addr, i) => (
												<button
													key={i}
													onClick={() => setPublicAddress(addr)}
													className="text-sm px-3 py-1 bg-gray-200 dark:bg-gray-700 rounded-md hover:bg-gray-300 dark:hover:bg-gray-600"
												>
													{addr.slice(0, 6)}...{addr.slice(-4)}
												</button>
											))}
										</div>
									</div>
								</div>
							)}

							{/* Error Display */}
							{error && (
								<div className="max-w-2xl mx-auto mb-8">
									<ErrorDisplay error={error} onRetry={() => setError(null)} />
								</div>
							)}

							{/* Loading State */}
							{loading && (
								<div className="max-w-2xl mx-auto mb-8">
									<LoadingSkeleton lines={3} />
								</div>
							)}

							{/* Store Data Display */}
							{storeData && !loading && (
								<div className="max-w-6xl mx-auto">
									<div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
										{/* Visualization */}
										<div className="space-y-6">
											<div className="bg-white dark:bg-gray-800 rounded-lg p-6 border border-gray-200 dark:border-gray-700 shadow-sm">
												<h3 className="text-lg font-semibold mb-4">Sensor Visualization</h3>
												<FloodboyVisualization storeData={storeData} currentBlock={currentBlock} />
											</div>
										</div>

										{/* Store Details */}
										<div className="space-y-6">
											<div className="bg-white dark:bg-gray-800 rounded-lg p-6 border border-gray-200 dark:border-gray-700 shadow-sm">
												<h3 className="text-lg font-semibold mb-4">Store Details</h3>
												<div className="space-y-2 text-sm">
													<div className="flex justify-between">
														<span className="text-gray-600 dark:text-gray-400">Address:</span>
														<span className="font-mono">{storeData.address.slice(0, 8)}...{storeData.address.slice(-6)}</span>
													</div>
													<div className="flex justify-between">
														<span className="text-gray-600 dark:text-gray-400">Owner:</span>
														<span className="font-mono">{storeData.owner.slice(0, 8)}...{storeData.owner.slice(-6)}</span>
													</div>
													<div className="flex justify-between">
														<span className="text-gray-600 dark:text-gray-400">Sensors:</span>
														<span>{storeData.sensorRecords.length}</span>
													</div>
													<div className="flex justify-between">
														<span className="text-gray-600 dark:text-gray-400">Fields:</span>
														<span>{storeData.fields.length}</span>
													</div>
												</div>
											</div>

											{/* Sensor Records */}
											{storeData.sensorRecords.length > 0 && (
												<div className="bg-white dark:bg-gray-800 rounded-lg p-6 border border-gray-200 dark:border-gray-700 shadow-sm">
													<h3 className="text-lg font-semibold mb-4">Latest Sensor Data</h3>
													{storeData.sensorRecords.map((record, i) => (
														<div key={i} className="mb-4 p-4 bg-gray-50 dark:bg-gray-700 rounded-lg">
															<div className="flex justify-between items-center mb-2">
																<span className="font-mono text-sm">{record.sensor.slice(0, 8)}...{record.sensor.slice(-6)}</span>
																<span className="text-xs text-gray-500">
																	{new Date(record.latestRecord.timestamp * 1000).toLocaleString()}
																</span>
															</div>
															<div className="grid grid-cols-2 gap-2 text-sm">
																{record.latestRecord.values.map((value, j) => (
																	<div key={j} className="flex justify-between">
																		<span className="text-gray-600 dark:text-gray-400">
																			{storeData.fields[j]?.name || `Field ${j}`}:
																		</span>
																		<span className="font-mono">
																			{value} {storeData.fields[j]?.unit || ''}
																		</span>
																	</div>
																))}
															</div>
														</div>
													))}
												</div>
											)}
										</div>
									</div>
								</div>
							)}
						</div>
					</div>
				);
			};

			// Render the app
			ReactDOM.render(<App />, document.getElementById('blockchain-app'));
		</script>
	</body>
</html>