---
import BaseHead from '../components/BaseHead.astro';
import Header from '../components/Header.astro';
import Footer from '../components/Footer.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../consts';
---

<!doctype html>
<html lang="en">
	<head>
		<BaseHead title={`Blockchain Dashboard | ${SITE_TITLE}`} description={SITE_DESCRIPTION} />
		
		<!-- React and Babel for JSX -->
		<script crossorigin src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
		<script crossorigin src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
		<script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
		
		<!-- Tailwind CSS -->
		<script src="https://cdn.tailwindcss.com"></script>
		
		<style>
			:root {
				--primary: #8b5cf6;
				--primary-dark: #7c3aed;
				--secondary: #3b82f6;
				--success: #10b981;
				--warning: #f59e0b;
				--danger: #ef4444;
				--dark: #0f0f1e;
				--light: #f9fafb;
			}
			
			body {
				margin: 0;
				font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
				background-color: #f9fafb;
				color: #1f2937;
				min-height: 100vh;
			}
			
			/* Gradient cards - make them more vibrant */
			.gradient-card-1 {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
			}
			
			.gradient-card-2 {
				background: linear-gradient(135deg, #f093fb 0%, #f5576c 100%);
			}
			
			.gradient-card-3 {
				background: linear-gradient(135deg, #4facfe 0%, #00f2fe 100%);
			}
			
			.gradient-card-4 {
				background: linear-gradient(135deg, #43e97b 0%, #38f9d7 100%);
			}
			
			.gradient-card-5 {
				background: linear-gradient(135deg, #fa709a 0%, #fee140 100%);
			}
			
			.gradient-card-6 {
				background: linear-gradient(135deg, #30cfd0 0%, #330867 100%);
			}
			
			.card {
				background: white;
				border-radius: 16px;
				box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06);
				transition: all 0.3s ease;
				overflow: hidden;
				position: relative;
			}
			
			/* Store cards should not have white background */
			.store-card.card {
				background: transparent;
			}
			
			.card:hover {
				transform: translateY(-4px);
				box-shadow: 0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04);
			}
			
			.store-card {
				position: relative;
				overflow: hidden;
				border-radius: 16px;
			}
			
			.store-card-gradient {
				position: absolute;
				inset: 0;
				opacity: 1;
				transition: all 0.3s ease;
				border-radius: 16px;
			}
			
			.store-card:hover .store-card-gradient {
				transform: scale(1.02);
			}
			
			.store-card-content {
				position: relative;
				z-index: 1;
				padding: 24px;
				color: white;
			}
			
			.btn {
				padding: 10px 20px;
				border-radius: 8px;
				font-weight: 500;
				transition: all 0.2s ease;
				cursor: pointer;
				border: none;
				display: inline-flex;
				align-items: center;
				gap: 8px;
				backdrop-filter: blur(10px);
			}
			
			.btn-primary {
				background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
				color: white;
				box-shadow: 0 4px 15px 0 rgba(102, 126, 234, 0.4);
			}
			
			.btn-primary:hover {
				transform: translateY(-2px);
				box-shadow: 0 6px 20px 0 rgba(102, 126, 234, 0.6);
			}
			
			.btn-secondary {
				background: #f3f4f6;
				color: #374151;
				border: 1px solid #e5e7eb;
			}
			
			.btn-secondary:hover {
				background: #e5e7eb;
				border: 1px solid #d1d5db;
			}
			
			.badge {
				padding: 4px 12px;
				border-radius: 20px;
				font-size: 12px;
				font-weight: 600;
				text-transform: uppercase;
				letter-spacing: 0.5px;
			}
			
			.badge-success {
				background: rgba(16, 185, 129, 0.2);
				color: #10f981;
				border: 1px solid rgba(16, 185, 129, 0.3);
			}
			
			.badge-warning {
				background: rgba(245, 158, 11, 0.2);
				color: #f59e0b;
				border: 1px solid rgba(245, 158, 11, 0.3);
			}
			
			.badge-info {
				background: rgba(59, 130, 246, 0.2);
				color: #3b82f6;
				border: 1px solid rgba(59, 130, 246, 0.3);
				color: #1e40af;
			}
			
			.skeleton {
				animation: shimmer 2s infinite;
				background: linear-gradient(90deg, #f3f4f6 25%, #e5e7eb 50%, #f3f4f6 75%);
				background-size: 200% 100%;
				border-radius: 4px;
			}
			
			@keyframes shimmer {
				0% { background-position: -200% 0; }
				100% { background-position: 200% 0; }
			}
			
			.line-clamp-2 {
				display: -webkit-box;
				-webkit-line-clamp: 2;
				-webkit-box-orient: vertical;
				overflow: hidden;
			}
			
			.fade-in {
				animation: fadeIn 0.5s ease-out;
			}
			
			@keyframes fadeIn {
				from { opacity: 0; transform: translateY(20px); }
				to { opacity: 1; transform: translateY(0); }
			}
			
			/* Header styling */
			.header-gradient {
				background: white;
				border-bottom: 1px solid #e5e7eb;
			}
			
			/* Network selector styling */
			.network-select {
				background: white;
				border: 1px solid #d1d5db;
				color: #374151;
				padding: 8px 12px;
				border-radius: 8px;
			}
			
			.network-select:focus {
				outline: none;
				border-color: #667eea;
				box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
			}
		</style>
	</head>
	<body>
		<Header />
		<main>
			<div id="blockchain-app"></div>
		</main>
		<Footer />

		<script type="module">
			// Import viem modules
			import { createPublicClient, http, parseAbi, formatEther, decodeEventLog } from 'https://esm.sh/viem@2.21.19';
			import { mainnet, sepolia, anvil } from 'https://esm.sh/viem@2.21.19/chains';
			
			// Custom chain configurations
			const jibchainL1 = {
				id: 8899,
				name: 'JIBCHAIN L1',
				network: 'jibchain',
				nativeCurrency: { name: 'JBC', symbol: 'JBC', decimals: 18 },
				rpcUrls: {
					default: { http: ['https://rpc-l1.jbc.xpool.pw'] },
					public: { http: ['https://rpc-l1.jbc.xpool.pw'] }
				},
				blockExplorers: {
					default: { name: 'JBC Explorer', url: 'https://exp.jibchain.net' }
				}
			};

			const sichang = {
				id: 700011,
				name: 'SiChang',
				network: 'sichang',
				nativeCurrency: { name: 'SIC', symbol: 'SIC', decimals: 18 },
				rpcUrls: {
					default: { http: ['https://rpc.sichang.sahalab.link'] },
					public: { http: ['https://rpc.sichang.sahalab.link'] }
				}
			};

			// Make chain configs available globally
			window.viem = { createPublicClient, http, parseAbi, formatEther, decodeEventLog };
			window.chains = { mainnet, sepolia, anvil, jibchainL1, sichang };

			// Contract configuration
			const CONTRACTS = {
				8899: {
					DEPLOYER_ADDRESS: '0x0000000000000000000000000000000000000000', // Update this with actual factory address when available
					STORE_ADDRESS: '0xc887E6FEdF2879ca0731F9b5d3D077F43f53D6e8'
				},
				700011: {
					DEPLOYER_ADDRESS: '0x0000000000000000000000000000000000000000',
					STORE_ADDRESS: '0x0000000000000000000000000000000000000000'
				},
				31337: {
					DEPLOYER_ADDRESS: '0x0000000000000000000000000000000000000000',
					STORE_ADDRESS: '0x0000000000000000000000000000000000000000'
				}
			};

			const DEPLOYER_ABI = [
				{
					"inputs": [{"internalType": "address", "name": "store", "type": "address"}],
					"name": "getNickname",
					"outputs": [{"internalType": "string", "name": "", "type": "string"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [{"internalType": "address", "name": "store", "type": "address"}],
					"name": "getStoreMetadata",
					"outputs": [
						{"internalType": "uint128", "name": "deployedBlock", "type": "uint128"},
						{"internalType": "uint128", "name": "lastUpdatedBlock", "type": "uint128"},
						{"internalType": "string", "name": "description", "type": "string"},
						{"internalType": "string", "name": "pointer", "type": "string"}
					],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"anonymous": false,
					"inputs": [
						{"indexed": true, "internalType": "address", "name": "creator", "type": "address"},
						{"indexed": false, "internalType": "address", "name": "store", "type": "address"},
						{"indexed": false, "internalType": "string", "name": "nickname", "type": "string"}
					],
					"name": "SensorStoreDeployed",
					"type": "event"
				}
			];

			const STORE_ABI = [
				{
					"inputs": [],
					"name": "getAllFields",
					"outputs": [{"components": [{"internalType": "string", "name": "name", "type": "string"}, {"internalType": "string", "name": "unit", "type": "string"}, {"internalType": "string", "name": "dtype", "type": "string"}], "internalType": "struct SecureSensorStore.Field[]", "name": "", "type": "tuple[]"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [{"internalType": "address", "name": "sensor", "type": "address"}],
					"name": "getLatestRecord",
					"outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}, {"internalType": "int256[]", "name": "", "type": "int256[]"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"inputs": [],
					"name": "owner",
					"outputs": [{"internalType": "address", "name": "", "type": "address"}],
					"stateMutability": "view",
					"type": "function"
				},
				{
					"anonymous": false,
					"inputs": [
						{"indexed": true, "internalType": "address", "name": "sensor", "type": "address"},
						{"indexed": false, "internalType": "uint256", "name": "timestamp", "type": "uint256"},
						{"indexed": false, "internalType": "int256[]", "name": "values", "type": "int256[]"}
					],
					"name": "RecordStored",
					"type": "event"
				}
			];

			// Make all configurations available globally
			window.CONTRACTS = CONTRACTS;
			window.DEPLOYER_ABI = DEPLOYER_ABI;
			window.STORE_ABI = STORE_ABI;
		</script>

		<script type="text/babel">
			const { useState, useEffect, useRef } = React;
			const { createPublicClient, http, parseAbi, formatEther, decodeEventLog } = window.viem;
			const { mainnet, sepolia, anvil, jibchainL1, sichang } = window.chains;

			// Helper functions
			const formatAddress = (address) => `${address.slice(0, 6)}...${address.slice(-4)}`;
			
			const formatValue = (value, unit) => {
				const num = BigInt(value);
				if (unit.includes('x 1000')) {
					return (Number(num) / 1000).toFixed(2);
				}
				if (unit.includes('x 100')) {
					return (Number(num) / 100).toFixed(2);
				}
				return num.toString();
			};
			
			const getTimeAgo = (timestamp) => {
				const date = new Date(parseInt(timestamp) * 1000);
				const seconds = Math.floor((new Date() - date) / 1000);
				if (seconds < 60) return `${seconds}s ago`;
				const minutes = Math.floor(seconds / 60);
				if (minutes < 60) return `${minutes}m ago`;
				const hours = Math.floor(minutes / 60);
				if (hours < 24) return `${hours}h ago`;
				return `${Math.floor(hours / 24)}d ago`;
			};

			// Icon components
			const Icons = {
				Refresh: () => (
					<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
						<path d="M3 12a9 9 0 0 1 9-9 9.75 9.75 0 0 1 6.74 2.74L21 8M21 3v5h-5M21 12a9 9 0 0 1-9 9 9.75 9.75 0 0 1-6.74-2.74L3 16M3 21v-5h5"/>
					</svg>
				),
				ChevronRight: () => (
					<svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
						<polyline points="9 18 15 12 9 6"/>
					</svg>
				),
				Database: () => (
					<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
						<ellipse cx="12" cy="5" rx="9" ry="3"/>
						<path d="M3 5v14c0 1.66 4.03 3 9 3s9-1.34 9-3V5"/>
						<path d="M3 12c0 1.66 4.03 3 9 3s9-1.34 9-3"/>
					</svg>
				),
				Activity: () => (
					<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
						<path d="M22 12h-2.48a2 2 0 0 0-1.93 1.46l-2.35 8.36a.25.25 0 0 1-.48 0L9.24 2.18a.25.25 0 0 0-.48 0l-2.35 8.36A2 2 0 0 1 4.49 12H2"/>
					</svg>
				),
				ExternalLink: () => (
					<svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
						<path d="M15 3h6v6M10 14 21 3M18 13v6a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2V8a2 2 0 0 1 2-2h6"/>
					</svg>
				),
				Back: () => (
					<svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
						<path d="m15 18-6-6 6-6"/>
					</svg>
				)
			};

			// Loading skeleton component
			const LoadingSkeleton = ({ className = "" }) => (
				<div className={`skeleton ${className}`}>&nbsp;</div>
			);

			// Store Card Component with gradient backgrounds
			const StoreCard = ({ store, index }) => {
				const gradientClasses = [
					'gradient-card-1',
					'gradient-card-2',
					'gradient-card-3',
					'gradient-card-4',
					'gradient-card-5',
					'gradient-card-6'
				];
				const gradientClass = gradientClasses[index % gradientClasses.length];
				
				return (
					<a href={`/blockchain/${store.address}`} className="block">
						<div className="store-card card cursor-pointer hover:scale-[1.02] transition-all fade-in">
							<div className={`store-card-gradient ${gradientClass}`}></div>
							<div className="store-card-content">
								<div className="flex items-start justify-between mb-4">
									<div className="flex items-center gap-2">
										<div className="w-10 h-10 bg-white/20 backdrop-blur rounded-lg flex items-center justify-center">
											<svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" strokeWidth="2">
												<path d="M12 2L2 7l10 5 10-5-10-5z"/>
												<path d="M2 17l10 5 10-5M2 12l10 5 10-5"/>
											</svg>
										</div>
										<div>
											<h3 className="text-lg font-bold text-white">
												{store.nickname || 'Unnamed Store'}
											</h3>
											<code className="text-xs text-white/70 font-mono">{formatAddress(store.address)}</code>
										</div>
									</div>
									{store.isOnline && (
										<span className="badge badge-success">Online</span>
									)}
								</div>
								
								{store.description && (
									<p className="text-white/80 text-sm mb-3 line-clamp-2">{store.description}</p>
								)}
								
								{store.location && (
									<p className="text-white/60 text-xs mb-4">📍 {store.location.split(' ').slice(0, 5).join(' ')}...</p>
								)}
								
								<div className="flex items-center justify-between">
									<div className="flex items-center gap-4 text-sm text-white/70">
										<span className="flex items-center gap-1 bg-white/10 px-3 py-1 rounded-full">
											<Icons.Database />
											{store.fieldCount || 0} fields
										</span>
										<span className="flex items-center gap-1 bg-white/10 px-3 py-1 rounded-full">
											<Icons.Activity />
											{store.sensorCount || 0} sensors
										</span>
									</div>
									<div className="w-8 h-8 bg-white/20 backdrop-blur rounded-full flex items-center justify-center">
										<Icons.ChevronRight />
									</div>
								</div>
							</div>
						</div>
					</a>
				);
			};


			// Main App Component
			const App = () => {
				const [publicClient, setPublicClient] = useState(null);
				const [chainId, setChainId] = useState(8899);
				const [stores, setStores] = useState([]);
				const [storeListLoading, setStoreListLoading] = useState(false);
				const [error, setError] = useState(null);
				const [currentBlock, setCurrentBlock] = useState(null);

				// Initialize public client
				useEffect(() => {
					const chain = chainId === 31337 ? anvil : 
								 chainId === 8899 ? jibchainL1 : 
								 chainId === 700011 ? sichang : jibchainL1;

					const client = createPublicClient({
						chain,
						transport: http()
					});

					setPublicClient(client);
				}, [chainId]);

				// Load stores on client change
				useEffect(() => {
					if (publicClient) {
						loadPublicStores();
					}
				}, [publicClient]);

				// Block monitoring
				useEffect(() => {
					if (!publicClient || chainId !== 8899) return;

					const updateBlock = async () => {
						try {
							const block = await publicClient.getBlockNumber();
							setCurrentBlock(Number(block));
						} catch (err) {
							console.error('Block update failed:', err);
						}
					};

					updateBlock();
					const interval = setInterval(updateBlock, 3000);
					return () => clearInterval(interval);
				}, [publicClient, chainId]);

				const loadPublicStores = async () => {
					if (!publicClient) return;

					setStoreListLoading(true);
					setError(null);

					try {
						// Try known stores first for better UX
						const knownStores = await loadKnownStores();
						if (knownStores.length > 0) {
							setStores(knownStores);
						}

						// Then try to load from factory
						const deployerAddress = CONTRACTS[chainId]?.DEPLOYER_ADDRESS;
						if (!deployerAddress || deployerAddress === "0x0000000000000000000000000000000000000000") {
							console.warn('Factory not configured for this network');
							return;
						}

						const eventAbi = parseAbi(['event SensorStoreDeployed(address indexed creator, address store, string nickname)'])[0];
						const currentBlockBigInt = await publicClient.getBlockNumber();
						const fromBlock = currentBlockBigInt > 50000n ? currentBlockBigInt - 50000n : 0n;

						const events = await publicClient.getLogs({
							address: deployerAddress,
							event: eventAbi,
							fromBlock: fromBlock,
							toBlock: currentBlockBigInt
						});

						if (events.length > 0) {
							const storePromises = events.map(async (event) => {
								try {
									const decoded = decodeEventLog({
										abi: [eventAbi],
										data: event.data,
										topics: event.topics
									});

									const storeAddress = decoded.args.store;
									const nickname = decoded.args.nickname;
									
									let fieldCount = 0;
									let sensorCount = 0;
									let isOnline = false;
									let lastUpdated = null;

									try {
										const fields = await publicClient.readContract({
											address: storeAddress,
											abi: STORE_ABI,
											functionName: 'getAllFields'
										});
										fieldCount = fields.length;

										const recordEventAbi = parseAbi(['event RecordStored(address indexed sensor, uint256 timestamp, int256[] values)'])[0];
										const recentEvents = await publicClient.getLogs({
											address: storeAddress,
											event: recordEventAbi,
											fromBlock: currentBlockBigInt > 1000n ? currentBlockBigInt - 1000n : 0n,
											toBlock: currentBlockBigInt
										});

										if (recentEvents.length > 0) {
											const uniqueSensors = new Set();
											let latestTimestamp = 0;

											recentEvents.forEach(evt => {
												const decodedRecord = decodeEventLog({
													abi: [recordEventAbi],
													data: evt.data,
													topics: evt.topics
												});
												uniqueSensors.add(decodedRecord.args.sensor);
												const timestamp = parseInt(decodedRecord.args.timestamp);
												if (timestamp > latestTimestamp) {
													latestTimestamp = timestamp;
												}
											});

											sensorCount = uniqueSensors.size;
											lastUpdated = latestTimestamp;
											isOnline = (Math.floor(Date.now() / 1000) - latestTimestamp) < 3600;
										}
									} catch (error) {
										console.warn('Error loading store details:', error);
									}

									return {
										address: storeAddress,
										nickname: nickname || `Store ${storeAddress.slice(-4)}`,
										fieldCount,
										sensorCount,
										isOnline,
										lastUpdated,
										deployedAt: event.blockNumber
									};

								} catch (error) {
									console.error('Error processing store:', error);
									return null;
								}
							});

							const storeResults = await Promise.all(storePromises);
							const validStores = storeResults.filter(store => store !== null);
							validStores.sort((a, b) => Number(b.deployedAt) - Number(a.deployedAt));

							setStores(validStores);
						}

					} catch (err) {
						console.error('Failed to load stores:', err);
						setError('Unable to load stores from factory');
					} finally {
						setStoreListLoading(false);
					}
				};

				const loadKnownStores = async () => {
					const knownStoreAddresses = [
						'0xc887E6FEdF2879ca0731F9b5d3D077F43f53D6e8', // Known flood monitoring store
					];

					const storePromises = knownStoreAddresses.map(async (storeAddress) => {
						try {
							const fields = await publicClient.readContract({
								address: storeAddress,
								abi: STORE_ABI,
								functionName: 'getAllFields'
							});

							const recordEventAbi = parseAbi(['event RecordStored(address indexed sensor, uint256 timestamp, int256[] values)'])[0];
							const currentBlockBigInt = await publicClient.getBlockNumber();
							const recentEvents = await publicClient.getLogs({
								address: storeAddress,
								event: recordEventAbi,
								fromBlock: currentBlockBigInt > 1000n ? currentBlockBigInt - 1000n : 0n,
								toBlock: currentBlockBigInt
							});

							let sensorCount = 0;
							let isOnline = false;
							let lastUpdated = null;

							if (recentEvents.length > 0) {
								const uniqueSensors = new Set();
								let latestTimestamp = 0;

								recentEvents.forEach(evt => {
									const decodedRecord = decodeEventLog({
										abi: [recordEventAbi],
										data: evt.data,
										topics: evt.topics
									});
									uniqueSensors.add(decodedRecord.args.sensor);
									const timestamp = parseInt(decodedRecord.args.timestamp);
									if (timestamp > latestTimestamp) {
										latestTimestamp = timestamp;
									}
								});

								sensorCount = uniqueSensors.size;
								lastUpdated = latestTimestamp;
								isOnline = (Math.floor(Date.now() / 1000) - latestTimestamp) < 3600;
							}

							return {
								address: storeAddress,
								nickname: `Flood Boy 001`,
								description: 'Flood monitoring station in Chiang Mai',
								location: '46 Soi Mu Ban Thep Prathan Phon Niwet Tambon Tha Sala',
								fieldCount: fields.length,
								sensorCount,
								isOnline,
								lastUpdated
							};

						} catch (error) {
							console.warn('Error loading known store:', error);
							return {
								address: storeAddress,
								nickname: `Flood Boy 001`,
								description: 'Flood monitoring station in Chiang Mai', 
								location: '46 Soi Mu Ban Thep Prathan Phon Niwet Tambon Tha Sala',
								fieldCount: 3,
								sensorCount: 1,
								isOnline: true,
								lastUpdated: Date.now()
							};
						}
					});

					const results = await Promise.all(storePromises);
					return results.filter(store => store !== null);
				};

				return (
					<div className="min-h-screen">
						<div className="header-gradient">
							<div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
								<div className="py-6">
									<div className="flex items-center justify-between">
										<div>
											<h1 className="text-3xl font-bold text-gray-900">
												IoT Blockchain Dashboard
											</h1>
											<p className="mt-1 text-sm text-gray-600">
												Real-time sensor data monitoring with blockchain verification
											</p>
										</div>
										
										{/* Network selector and block info */}
										<div className="flex items-center gap-4">
											<select
												value={chainId}
												onChange={(e) => setChainId(parseInt(e.target.value))}
												className="network-select"
											>
												<option value={8899}>JIBCHAIN L1</option>
												<option value={700011}>SiChang</option>
												<option value={31337}>Anvil Local</option>
											</select>
											
											{currentBlock && chainId === 8899 && (
												<div className="text-sm">
													<span className="text-gray-600">Block:</span>
													<span className="ml-1 font-mono font-medium text-gray-900">{currentBlock.toLocaleString()}</span>
												</div>
											)}
										</div>
									</div>
								</div>
							</div>
						</div>

						<div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-8">
							{/* Error Display */}
							{error && (
								<div className="mb-6 p-4 bg-red-50 border border-red-200 rounded-lg">
									<p className="text-red-700">{error}</p>
								</div>
							)}

							{/* Main Content */}
							<div>
									{/* Store List Header */}
									<div className="flex items-center justify-between mb-6">
										<div>
											<h2 className="text-2xl font-bold text-gray-900">Public Stores</h2>
											<p className="text-gray-600">Sensor stores with access control</p>
										</div>
										<button
											onClick={loadPublicStores}
											disabled={storeListLoading}
											className="btn btn-primary"
										>
											<Icons.Refresh />
											{storeListLoading ? 'Loading...' : 'Refresh'}
										</button>
									</div>

									{/* Store Grid */}
									{storeListLoading ? (
										<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
											{[1, 2, 3].map(i => (
												<div key={i} className="card p-6">
													<LoadingSkeleton className="h-6 w-3/4 mb-2" />
													<LoadingSkeleton className="h-4 w-1/2 mb-4" />
													<LoadingSkeleton className="h-16 mb-4" />
													<LoadingSkeleton className="h-4 w-full" />
												</div>
											))}
										</div>
									) : stores.length > 0 ? (
										<div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
											{stores.map((store, index) => (
												<StoreCard
													key={store.address}
													store={store}
													index={index}
												/>
											))}
										</div>
									) : (
										<div className="text-center py-16">
											<Icons.Database />
											<p className="mt-4 text-gray-600">No stores found</p>
											<p className="text-sm text-gray-500 mt-1">
												Try refreshing or check the network connection
											</p>
										</div>
									)}
							</div>
						</div>
					</div>
				);
			};

			// Render the app
			ReactDOM.render(<App />, document.getElementById('blockchain-app'));
		</script>
	</body>
</html>